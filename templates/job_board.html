{% extends "base.html" %}

{% block title %}Job Board - TrueTank{% endblock %}

{% block head %}
<!-- Leaflet CSS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" 
      integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
{% endblock %}

{% block content %}
<div class="job-board-container">
    <div class="board-header">
        <h2>Daily Job Scheduler</h2>
        <div class="header-controls">
            <div class="date-navigation">
                <button id="prev-day" class="btn btn-sm btn-secondary">‚Äπ Previous</button>
                <input type="date" id="selected-date" class="date-picker" value="">
                <button id="next-day" class="btn btn-sm btn-secondary">Next ‚Ä∫</button>
                <button id="today-btn" class="btn btn-sm btn-primary">Today</button>
            </div>
            <div class="board-actions">
                <a href="{{ url_for('create_ticket') }}" class="btn-new-job">New Job</a>
            </div>
        </div>
    </div>
    
    <div class="truck-scheduler">
        <!-- Pending Column (Left) -->
        <div class="pending-column">
            <div class="column-header">
                <h3>Pending Jobs</h3>
                <span id="pending-count" class="badge">0</span>
            </div>
            
            <!-- Search Bar -->
            <div class="search-controls">
                <input type="text" id="search-pending" class="search-input" placeholder="Search tickets...">
            </div>
            
            <!-- Sort Controls -->
            <div class="sort-controls">
                <label for="sort-pending">Sort by:</label>
                <select id="sort-pending" class="sort-select">
                    <option value="oldest">Oldest first</option>
                    <option value="due_date">Due date</option>
                    <option value="priority">Priority</option>
                    <option value="customer">Customer name</option>
                </select>
            </div>
            
            <div id="pending-tickets" class="ticket-list pending-ticket-list">
                <!-- Pending tickets will be loaded here -->
            </div>
        </div>
        
        <!-- Truck Columns (Right) -->
        <div class="truck-columns" id="truck-columns">
            <!-- Truck columns will be dynamically generated here -->
        </div>
    </div>
    
    <!-- Team Assignment Modal -->
    <div id="team-assignment-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Assign Team Member</h3>
                <span class="close" onclick="closeTeamModal()">&times;</span>
            </div>
            <div class="modal-body">
                <p>Select team member for <span id="modal-truck-name"></span> on <span id="modal-date"></span>:</p>
                <select id="team-member-select">
                    <option value="">No assignment</option>
                    {% for member in team_members %}
                    <option value="{{ member.id }}">{{ member.first_name }} {{ member.last_name }} ({{ member.position }})</option>
                    {% endfor %}
                </select>
            </div>
            <div class="modal-actions">
                <button class="btn btn-secondary" onclick="closeTeamModal()">Cancel</button>
                <button class="btn btn-primary" onclick="saveTeamAssignment()">Assign</button>
            </div>
        </div>
    </div>

    <!-- Dump Info Modal -->
    <div id="dump-info-modal" class="modal" style="display: none; z-index: 1100;">
        <div class="modal-content dump-modal-content">
            <div class="modal-header">
                <h3>üóëÔ∏è Add Dump Stop</h3>
                <span class="close" onclick="closeDumpInfoModal()">&times;</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="dump-site-select">Select Dump Site:</label>
                    <select id="dump-site-select" class="form-input" required>
                        <option value="">Loading dump sites...</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="dump-duration">Estimated Duration (minutes):</label>
                    <input type="number" id="dump-duration" class="form-input" value="30" min="10" max="120">
                </div>
            </div>
            <div class="modal-actions">
                <button class="btn btn-secondary" onclick="closeDumpInfoModal()">Cancel</button>
                <button class="btn btn-primary" onclick="confirmAddDump()">Add Dump</button>
            </div>
        </div>
    </div>

    <!-- Truck Route Map Modal -->
    <div id="truck-map-modal" class="modal" style="display: none;">
        <div class="modal-content map-modal-content">
            <div class="modal-header">
                <button class="btn btn-primary header-btn" onclick="calculateRoute()" id="routeBtn">üó∫Ô∏è Calculate Route</button>
                <h3>üó∫Ô∏è Route Map - <span id="map-truck-name"></span></h3>
                <div id="inline-loading-indicator" class="inline-loading" style="display: none;">
                    <div class="mini-progress-bar">
                        <div id="mini-progress-fill" class="mini-progress-fill"></div>
                    </div>
                    <span id="mini-progress-percent" class="mini-progress-text">0%</span>
                </div>
                <span class="close" onclick="closeTruckMapModal()">&times;</span>
            </div>
            <div class="modal-body">
                <div class="map-layout-container">
                    <div id="route-summary" class="route-summary-sidebar">
                        <!-- Truck Information Section -->
                        <div class="truck-info-section">
                            <h4>üöõ <span id="sidebar-truck-name"></span></h4>
                            <div class="truck-details">
                                <div id="truck-specs" class="detail-item">
                                    <span class="detail-label">Vehicle:</span>
                                    <span id="truck-make-model" class="detail-value"></span>
                                </div>
                                <div id="truck-capacity" class="detail-item">
                                    <span class="detail-label">Capacity:</span>
                                    <span id="truck-capacity-value" class="detail-value"></span>
                                </div>
                                <div id="truck-location" class="detail-item">
                                    <span class="detail-label">Location:</span>
                                    <span class="detail-value">Equipment Storage</span>
                                </div>
                            </div>
                            
                            <!-- Tank Status (Compact) -->
                            <div class="tank-status-compact">
                                <div class="tank-header">
                                    <span class="tank-icon">üõ¢Ô∏è</span>
                                    <span id="tank-status-badge" class="tank-badge tank-badge-ok">OK</span>
                                    <span id="tank-percentage" class="tank-percent">0%</span>
                                </div>
                                <div class="tank-bar-compact">
                                    <div id="tank-fill-compact" class="tank-fill-compact"></div>
                                    <div id="tank-threshold-compact" class="tank-threshold-compact"></div>
                                </div>
                                <div class="tank-info">
                                    <span id="tank-current-gallons">0</span>/<span id="tank-capacity-gallons">0</span> gal
                                    <span id="tank-until-dump" class="tank-until-dump">‚Ä¢ 0 until dump</span>
                                </div>
                                <div id="tank-dump-warning" class="tank-dump-warning" style="display: none;">
                                    ‚ö†Ô∏è Dump required before next jobs
                                </div>
                            </div>
                            
                            <!-- Dump Controls -->
                            <div class="dump-controls-section">
                                <h5>üóëÔ∏è Waste Disposal</h5>
                                <div class="dump-buttons">
                                    <button id="add-manual-dump-btn" class="btn-dump btn-dump-manual" onclick="addManualDumpCard()">
                                        ‚ûï Add Dump
                                    </button>
                                    <button id="add-auto-dump-btn" class="btn-dump btn-dump-auto" onclick="addAutoDumpCard()">
                                        üéØ Optimize Dumps
                                    </button>
                                </div>
                            </div>
                        </div>

                        <!-- Team Assignment Section -->
                        <div class="team-info-section">
                            <h5>üë§ Team Assignment</h5>
                            <div id="assigned-team-member" class="team-member-info">
                                <!-- Team member info will be populated here -->
                            </div>
                        </div>

                        <!-- Route Summary Section -->
                        <div class="route-section">
                            <h5>üìç Route Summary for <span id="summary-date"></span></h5>
                            <div id="route-jobs-list" class="route-jobs-list">
                                <!-- Jobs will be populated here -->
                            </div>
                        </div>
                    </div>
                    <div id="map-container" class="map-main-area">
                        <div id="truck-map" style="height: 600px; width: 100%;"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

</div>

<style>
.job-board-container {
    max-width: 100%;
    margin: 0 auto;
    padding: 1rem;
}

.board-header {
    margin-bottom: 2rem;
    padding-bottom: 1rem;
    border-bottom: 2px solid #ecf0f1;
}

.board-header h2 {
    color: #2c3e50;
    margin-bottom: 1rem;
}

.header-controls {
    display: flex;
    gap: 2rem;
    align-items: center;
    flex-wrap: wrap;
}

.date-navigation {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.date-picker {
    padding: 0.5rem;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 1rem;
}

.search-controls {
    margin-bottom: 1rem;
}

.search-input {
    width: 100%;
    padding: 0.5rem;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 0.9rem;
    box-sizing: border-box;
}

.search-input:focus {
    outline: none;
    border-color: #3498db;
    box-shadow: 0 0 5px rgba(52, 152, 219, 0.3);
}

.sort-controls {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 1rem;
}

.sort-controls label {
    font-size: 0.9rem;
    color: #666;
}

.sort-select {
    flex: 1;
    padding: 0.5rem;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 0.9rem;
}

.board-actions {
    display: flex;
    gap: 0.5rem;
    margin-left: auto;
}

.truck-scheduler {
    display: grid;
    grid-template-columns: 300px 1fr;
    gap: 1rem;
    height: calc(100vh - 200px);
    overflow: hidden;
}

.pending-column {
    background: #f5f5f5;
    border-radius: 8px;
    padding: 1rem;
    max-height: calc(100vh - 200px);
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

/* Ensure pending tickets have white background */
.pending-column .ticket-card {
    background-color: #ffffff;
    background: white;
}

/* Make pending ticket list scrollable */
.pending-ticket-list {
    flex: 1;
    overflow-y: auto;
    overflow-x: hidden;
}

.column-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
    padding-bottom: 0.5rem;
    border-bottom: 1px solid #ddd;
}

.column-header h3 {
    margin: 0;
    color: #2c3e50;
}

.badge {
    background: #3498db;
    color: white;
    padding: 0.25rem 0.5rem;
    border-radius: 12px;
    font-size: 0.8rem;
    font-weight: bold;
}

.truck-columns {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 1rem;
    overflow-x: auto;
    overflow-y: hidden;
}

.truck-column {
    background: #f5f5f5;
    border: 1px solid #ddd;
    border-radius: 8px;
    min-height: 400px;
    max-height: calc(100vh - 200px);
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

.truck-header {
    background: #34495e;
    color: white;
    padding: 1rem;
    border-radius: 8px 8px 0 0;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.truck-title-section h4 {
    margin: 0;
    font-size: 1.1rem;
}

.truck-title-section .truck-info {
    font-size: 0.9rem;
    opacity: 0.8;
    margin-top: 0.25rem;
}

.truck-actions {
    display: flex;
    gap: 0.5rem;
}

.truck-action-btn {
    background: rgba(255, 255, 255, 0.2);
    color: white;
    border: 1px solid rgba(255, 255, 255, 0.3);
    border-radius: 4px;
    padding: 0.4rem 0.6rem;
    font-size: 0.8rem;
    cursor: pointer;
    transition: all 0.2s ease;
}

.truck-action-btn:hover {
    background: rgba(255, 255, 255, 0.3);
    border-color: rgba(255, 255, 255, 0.5);
    transform: translateY(-1px);
}

.map-btn {
    background: rgba(52, 152, 219, 0.3);
}

.map-btn:hover {
    background: rgba(52, 152, 219, 0.5);
}

.team-btn {
    background: rgba(39, 174, 96, 0.3);
}

.team-btn:hover {
    background: rgba(39, 174, 96, 0.5);
}

.team-assignment {
    background: #ecf0f1;
    padding: 0.5rem 1rem;
    border-bottom: 1px solid #ddd;
    font-size: 0.9rem;
    color: #7f8c8d;
}

.ticket-list {
    flex: 1;
    padding: 1rem;
    min-height: 300px;
    overflow-y: auto;
    overflow-x: hidden;
}

.ticket-card {
    background-color: #ffffff !important;
    background: white;
    border: 1px solid #ddd;
    border-radius: 6px;
    padding: 0.5rem;
    margin-bottom: 0.35rem;
    cursor: move;
    transition: all 0.2s ease, transform 0.15s ease;
    border-left: 3px solid #3498db;
    min-height: 60px;
    box-shadow: 0 1px 2px rgba(0,0,0,0.05);
}

.ticket-card:hover {
    box-shadow: 0 1px 4px rgba(0,0,0,0.15);
    transform: translateY(-1px);
}

.ticket-card.priority-urgent {
    border-left-color: #e74c3c;
}

.ticket-card.priority-high {
    border-left-color: #f39c12;
}

.ticket-card.priority-medium {
    border-left-color: #3498db;
}

.ticket-card.priority-low {
    border-left-color: #95a5a6;
}

.ticket-card.dragging {
    opacity: 0.5;
    transform: rotate(5deg);
}

.ticket-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 0.5rem;
}

.ticket-id {
    font-weight: bold;
    color: #2c3e50;
    font-size: 0.9rem;
}

.priority-badge {
    padding: 0.15rem 0.3rem;
    border-radius: 3px;
    font-size: 0.65rem;
    font-weight: 600;
    text-transform: uppercase;
}

.priority-urgent {
    background: #e74c3c;
    color: white;
}

.priority-high {
    background: #f39c12;
    color: white;
}

.priority-medium {
    background: #3498db;
    color: white;
}

.priority-low {
    background: #95a5a6;
    color: white;
}

.ticket-customer {
    font-weight: 600;
    color: #2c3e50;
    margin-bottom: 0.25rem;
}

.ticket-service {
    color: #7f8c8d;
    font-size: 0.9rem;
    margin-bottom: 0.25rem;
}

.ticket-due {
    color: #95a5a6;
    font-size: 0.75rem;
    margin-top: 0.2rem;
}

.ticket-actions {
    margin-top: 0.5rem;
    padding-top: 0.5rem;
    border-top: 1px solid #ecf0f1;
}

.btn-action {
    background: #3498db;
    color: white;
    border: none;
    padding: 0.25rem 0.5rem;
    border-radius: 4px;
    font-size: 0.7rem;
    cursor: pointer;
    transition: background-color 0.2s;
}

.btn-action:hover {
    background: #2980b9;
}

.btn-new-job {
    background: linear-gradient(135deg, #27ae60, #2ecc71);
    color: white;
    text-decoration: none;
    display: inline-block;
    padding: 0.75rem 1.5rem;
    border-radius: 8px;
    font-size: 0.95rem;
    font-weight: 600;
    text-align: center;
    box-shadow: 0 4px 12px rgba(39, 174, 96, 0.3);
    transition: all 0.3s ease;
    border: none;
    cursor: pointer;
}

.btn-new-job:hover {
    background: linear-gradient(135deg, #229954, #27ae60);
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(39, 174, 96, 0.4);
    text-decoration: none;
    color: white;
}

.btn-new-job:active {
    transform: translateY(0);
    box-shadow: 0 2px 8px rgba(39, 174, 96, 0.3);
}

.drop-zone {
    border: 2px dashed #3498db;
    background: rgba(52, 152, 219, 0.1);
    border-radius: 6px;
    padding: 1rem;
    text-align: center;
    color: #3498db;
    margin: 0.5rem 0;
}

.drop-zone.drag-over {
    background: rgba(52, 152, 219, 0.2);
    border-color: #2980b9;
}

.no-results {
    text-align: center;
    color: #7f8c8d;
    font-style: italic;
    padding: 2rem 1rem;
    border: 2px dashed #ecf0f1;
    border-radius: 6px;
    margin: 1rem 0;
}

/* Clean Drag and Drop Styles */
.dragging-card {
    cursor: grabbing !important;
    opacity: 0.95 !important;
    transform: rotate(-2deg) !important;
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2) !important;
}

.drop-placeholder {
    background: #f0f8ff;
    border: 2px dashed #3498db;
    border-radius: 6px;
    padding: 0.5rem;
    margin: 0.25rem;
    text-align: center;
    color: #3498db;
    font-weight: 500;
    font-size: 0.85rem;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.15s ease;
    animation: placeholderSlideIn 0.15s ease-out;
}

@keyframes placeholderSlideIn {
    from {
        opacity: 0;
        transform: scaleY(0);
        margin-top: 0;
        margin-bottom: 0;
        padding-top: 0;
        padding-bottom: 0;
    }
    to {
        opacity: 1;
        transform: scaleY(1);
        margin-top: 0.25rem;
        margin-bottom: 0.25rem;
        padding-top: 0.5rem;
        padding-bottom: 0.5rem;
    }
}

/* Compact Ticket Cards for Truck Columns */
.ticket-card-compact {
    background: white;
    border: 1px solid #ddd;
    border-radius: 6px;
    padding: 0.5rem;
    margin-bottom: 0.35rem;
    cursor: move;
    transition: all 0.2s ease, transform 0.15s ease;
    border-left: 3px solid #3498db;
    min-height: 45px;
}

/* Animate cards when they move to fill space */
.ticket-list {
    transition: all 0.15s ease;
}

.ticket-card-animate,
.ticket-card-compact-animate {
    animation: cardSlideUp 0.2s ease-out;
}

@keyframes cardSlideUp {
    from {
        transform: translateY(20px);
        opacity: 0.8;
    }
    to {
        transform: translateY(0);
        opacity: 1;
    }
}

.ticket-card-compact:hover {
    box-shadow: 0 1px 4px rgba(0,0,0,0.15);
    transform: translateY(-1px);
}

.ticket-card-compact.priority-urgent {
    border-left-color: #e74c3c;
}

.ticket-card-compact.priority-high {
    border-left-color: #f39c12;
}

.ticket-card-compact.priority-medium {
    border-left-color: #3498db;
}

.ticket-card-compact.priority-low {
    border-left-color: #95a5a6;
}

.ticket-card-compact.dragging {
    opacity: 0.5;
    transform: rotate(3deg);
}

.compact-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.25rem;
}

.compact-customer-name {
    font-weight: bold;
    color: #2c3e50;
    font-size: 0.9rem;
}

.compact-service {
    color: #7f8c8d;
    font-size: 0.8rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.btn-compact-action {
    background: #3498db;
    color: white;
    border: none;
    width: 18px;
    height: 18px;
    border-radius: 3px;
    font-size: 0.8rem;
    font-weight: bold;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background-color 0.2s;
    line-height: 1;
}

.btn-compact-action:hover {
    background: #2980b9;
}

/* Pending Card Styles - Match compact design but with more info */
.pending-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.25rem;
}

.pending-job-id {
    font-weight: bold;
    color: #2c3e50;
    font-size: 0.9rem;
}

.pending-customer {
    font-weight: 500;
    color: #2c3e50;
    margin-bottom: 0.2rem;
    font-size: 0.85rem;
}

.pending-service {
    color: #7f8c8d;
    font-size: 0.8rem;
    margin-bottom: 0.15rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.pending-address {
    color: #95a5a6;
    font-size: 0.75rem;
    margin-bottom: 0.15rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    font-style: italic;
}

/* Modal Styles */
.modal {
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.5);
}

/* Header button styling */
.header-btn {
    margin-right: 1rem;
    padding: 0.5rem 1rem;
    font-size: 0.9rem;
}

/* Dump info modal styling */
.dump-modal-content {
    width: 90%;
    max-width: 500px;
    margin: 10% auto;
}

.form-group {
    margin-bottom: 1rem;
}

.form-group label {
    display: block;
    margin-bottom: 0.25rem;
    font-weight: 600;
    color: #2c3e50;
}

.form-input {
    width: 100%;
    padding: 0.5rem;
    border: 1px solid #dee2e6;
    border-radius: 4px;
    font-size: 0.9rem;
}

.form-input:focus {
    outline: none;
    border-color: #3498db;
    box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.1);
}

.modal-content {
    background-color: #fefefe;
    margin: 15% auto;
    padding: 0;
    border-radius: 8px;
    width: 90%;
    max-width: 500px;
}

.modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1rem;
    border-bottom: 1px solid #ecf0f1;
}

.modal-header h3 {
    margin: 0;
    color: #2c3e50;
}

.close {
    color: #aaa;
    font-size: 28px;
    font-weight: bold;
    cursor: pointer;
}

.close:hover {
    color: #000;
}

.modal-body {
    padding: 1rem;
}

.modal-actions {
    display: flex;
    gap: 1rem;
    justify-content: flex-end;
    padding: 1rem;
    border-top: 1px solid #ecf0f1;
}


/* Inline Loading Indicator */
.inline-loading {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-left: auto;
    margin-right: 1rem;
}

.mini-progress-bar {
    width: 80px;
    height: 4px;
    background: #e9ecef;
    border-radius: 2px;
    overflow: hidden;
}

.mini-progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #3498db, #2ecc71);
    width: 0%;
    transition: width 0.2s ease;
    border-radius: 2px;
}

.mini-progress-text {
    font-size: 0.75rem;
    color: #3498db;
    font-weight: 500;
    min-width: 25px;
}

/* Map Modal Styles */
.modal {
    display: flex;
    align-items: center;
    justify-content: center;
}

.map-modal-content {
    width: 95%;
    max-width: 1300px;
    max-height: 90vh;
    margin: 0;
    display: flex;
    flex-direction: column;
}

.map-layout-container {
    display: flex;
    gap: 1rem;
    height: 600px;
    min-height: 600px;
}

.route-summary-sidebar {
    width: 380px;
    min-width: 380px;
    padding: 1rem;
    background: #f8f9fa;
    border-radius: 6px;
    border: 1px solid #e9ecef;
    display: flex;
    flex-direction: column;
    gap: 1rem;
    overflow-y: auto;
    max-height: 600px;
}

/* Truck Information Section */
.truck-info-section {
    border-bottom: 1px solid #dee2e6;
    padding-bottom: 1rem;
}

.truck-info-section h4 {
    margin: 0 0 0.75rem 0;
    color: #2c3e50;
    font-size: 1.1rem;
}

.truck-details {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

.detail-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 0.9rem;
}

.detail-label {
    color: #6c757d;
    font-weight: 500;
}

.detail-value {
    color: #2c3e50;
    font-weight: 600;
}

/* Team Assignment Section */
.team-info-section {
    border-bottom: 1px solid #dee2e6;
    padding-bottom: 1rem;
}

.team-info-section h5 {
    margin: 0 0 0.75rem 0;
    color: #2c3e50;
    font-size: 1rem;
}

/* Tank Status Compact - Inside Truck Info */
.tank-status-compact {
    background: #f8f9fa;
    border-radius: 6px;
    padding: 0.75rem;
    border: 1px solid #e9ecef;
    margin-top: 0.75rem;
}

.tank-header {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 0.5rem;
}

.tank-icon {
    font-size: 1rem;
}

.tank-badge {
    padding: 0.15rem 0.4rem;
    border-radius: 12px;
    font-size: 0.7rem;
    font-weight: 600;
    text-transform: uppercase;
}

.tank-badge-ok {
    background: #d4edda;
    color: #155724;
}

.tank-badge-warning {
    background: #fff3cd;
    color: #856404;
}

.tank-badge-danger {
    background: #f8d7da;
    color: #721c24;
}

.tank-percent {
    margin-left: auto;
    font-weight: 600;
    font-size: 1rem;
    color: #495057;
}

.tank-bar-compact {
    position: relative;
    height: 8px;
    background: #e9ecef;
    border-radius: 4px;
    overflow: hidden;
    margin-bottom: 0.5rem;
}

.tank-fill-compact {
    height: 100%;
    border-radius: inherit;
    transition: width 0.3s ease, background 0.3s ease;
    width: 0%;
}

.tank-threshold-compact {
    position: absolute;
    top: 0;
    height: 100%;
    width: 2px;
    background: #dc3545;
    left: 85%;
    z-index: 1;
}

.tank-info {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 0.8rem;
    color: #6c757d;
}

.tank-until-dump {
    color: #495057;
}

.tank-dump-warning {
    background: #fff3cd;
    color: #856404;
    padding: 0.4rem 0.6rem;
    border-radius: 4px;
    font-size: 0.8rem;
    margin-top: 0.5rem;
    text-align: center;
    border: 1px solid #ffeaa7;
}

/* Dump Controls */
.dump-controls-section {
    border-top: 1px solid #dee2e6;
    padding-top: 1rem;
}

.dump-controls-section h5 {
    margin: 0 0 0.75rem 0;
    color: #2c3e50;
    font-size: 1rem;
}

.dump-buttons {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

.btn-dump {
    padding: 0.75rem 1rem;
    border: none;
    border-radius: 6px;
    font-size: 0.85rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
}

.btn-dump-manual {
    background: linear-gradient(135deg, #3498db, #2980b9);
    color: white;
    border: 1px solid #2980b9;
}

.btn-dump-manual:hover {
    background: linear-gradient(135deg, #2980b9, #1f618d);
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.15);
}

.btn-dump-auto {
    background: linear-gradient(135deg, #27ae60, #229954);
    color: white;
    border: 1px solid #229954;
}

.btn-dump-auto:hover {
    background: linear-gradient(135deg, #229954, #1e8449);
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.15);
}

/* Manual and Auto Dump Card Styling */
.manual-dump {
    border-left: 4px solid #3498db;
}

.manual-dump .dump-order {
    background: linear-gradient(135deg, #3498db, #2980b9);
}

.auto-dump {
    border-left: 4px solid #27ae60;
}

.auto-dump .dump-order {
    background: linear-gradient(135deg, #27ae60, #229954);
}

/* Dump indicator styling - no bar needed */
.dump-indicator {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0.5rem;
    min-height: 40px;
}

.dump-indicator .tank-gallons-change {
    font-size: 0.8rem;
    font-weight: 700;
}

.team-member-info {
    padding: 0.75rem;
    background: white;
    border-radius: 4px;
    border: 1px solid #e9ecef;
}

.team-member-assigned {
    color: #27ae60;
    font-weight: 600;
}

.team-member-unassigned {
    color: #95a5a6;
    font-style: italic;
}

/* Route Summary Section */
.route-section {
    display: flex;
    flex-direction: column;
}

.route-section h5 {
    margin: 0 0 0.75rem 0;
    color: #2c3e50;
    font-size: 1rem;
}

.route-jobs-list {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

.route-dump-stop {
    background: linear-gradient(135deg, #e67e22, #f39c12) !important;
    border-left: 4px solid #d35400 !important;
    color: white !important;
}

.route-dump-stop .job-time,
.route-dump-stop .dump-service,
.route-dump-stop .dump-location,
.route-dump-stop .dump-address {
    color: white !important;
}

.dump-order {
    background: #d35400 !important;
    color: white !important;
    font-size: 1.2rem;
    display: flex;
    align-items: center;
    justify-content: center;
}

.dump-service {
    font-weight: 600;
    text-transform: uppercase;
    font-size: 0.75rem;
    letter-spacing: 0.5px;
}

.tank-fill-indicator {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-top: 0.5rem;
    padding: 0.25rem;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 4px;
    font-size: 0.7rem;
}

.tank-fill-bar {
    flex: 1;
    height: 8px;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 4px;
    overflow: hidden;
    border: 1px solid rgba(255, 255, 255, 0.3);
}

.tank-fill-level {
    height: 100%;
    transition: width 0.3s ease;
    border-radius: 3px;
}

.tank-fill-text {
    min-width: 30px;
    text-align: right;
    font-weight: 600;
    font-size: 0.65rem;
}

.tank-gallons-change {
    min-width: 50px;
    text-align: right;
    font-weight: 600;
    font-size: 0.65rem;
    margin-left: 0.25rem;
    padding: 2px 4px;
    border-radius: 3px;
    text-shadow: 0 1px 2px rgba(0,0,0,0.3);
}
.tank-gallons-change.positive {
    color: #ffffff;
    background: rgba(46, 204, 113, 0.8);
    border: 1px solid rgba(46, 204, 113, 0.6);
}
.tank-gallons-change.negative {
    color: #ffffff;
    background: rgba(231, 76, 60, 0.8);
    border: 1px solid rgba(231, 76, 60, 0.6);
}


.tank-overfull .tank-fill-text {
    color: #e74c3c;
    font-weight: 700;
}

.route-dump-stop .tank-fill-indicator {
    background: rgba(255, 255, 255, 0.2);
}

.route-dump-stop .tank-fill-bar {
    border: 1px solid rgba(255, 255, 255, 0.4);
}

.map-main-area {
    flex: 1;
    min-width: 0;
}

.route-job-item {
    display: flex;
    align-items: center;
    padding: 0.75rem;
    background: white;
    border: 1px solid #dee2e6;
    border-radius: 4px;
    border-left: 3px solid #3498db;
    cursor: pointer;
    transition: all 0.2s ease, transform 0.15s ease;
    user-select: none;
    flex-shrink: 0;
    position: relative;
}

/* Delete button for dump cards */
.dump-delete-btn {
    position: absolute;
    top: 4px;
    left: 4px;
    width: 20px;
    height: 20px;
    padding: 0;
    border: none;
    background: rgba(231, 76, 60, 0.9);
    color: white;
    font-size: 16px;
    font-weight: bold;
    line-height: 1;
    border-radius: 3px;
    cursor: pointer;
    z-index: 10;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
}

.dump-delete-btn:hover {
    background: #c0392b;
    transform: scale(1.1);
}

/* Animate route items when order changes */
.route-job-item-animate {
    animation: routeItemSlide 0.2s ease-out;
}

@keyframes routeItemSlide {
    from {
        transform: translateY(10px);
        opacity: 0.8;
    }
    to {
        transform: translateY(0);
        opacity: 1;
    }
}

.route-job-item:hover {
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    transform: translateY(-1px);
    background: #f8f9fa;
    border-color: #3498db;
}

.route-job-item.dragging-route {
    opacity: 0.5;
    transform: rotate(2deg) scale(0.95);
}

.route-drop-placeholder {
    background: #f0f8ff;
    border: 2px dashed #3498db;
    border-radius: 4px;
    padding: 0.75rem;
    text-align: center;
    color: #3498db;
    font-weight: 500;
    font-size: 0.85rem;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.15s ease;
    animation: routePlaceholderSlideIn 0.15s ease-out;
    min-height: 60px;
}

@keyframes routePlaceholderSlideIn {
    from {
        opacity: 0;
        transform: scaleY(0);
        margin-top: 0;
        margin-bottom: 0;
        padding-top: 0;
        padding-bottom: 0;
    }
    to {
        opacity: 1;
        transform: scaleY(1);
        padding-top: 0.75rem;
        padding-bottom: 0.75rem;
    }
}

.route-job-item.priority-urgent {
    border-left-color: #e74c3c;
}

.route-job-item.priority-high {
    border-left-color: #f39c12;
}

.route-job-item.priority-medium {
    border-left-color: #3498db;
}

.route-job-item.priority-low {
    border-left-color: #95a5a6;
}

.job-order {
    background: #3498db;
    color: white;
    border-radius: 50%;
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.8rem;
    font-weight: bold;
    margin-right: 0.75rem;
    flex-shrink: 0;
}

.job-details {
    flex: 1;
}

.job-time {
    font-weight: bold;
    color: #2c3e50;
    margin-right: 0.5rem;
}

.job-service {
    color: #34495e;
    margin-right: 0.5rem;
}

.job-customer {
    color: #7f8c8d;
    font-size: 0.9rem;
}

.job-address {
    color: #95a5a6;
    font-size: 0.85rem;
    margin-top: 0.25rem;
}

@media (max-width: 768px) {
    .truck-scheduler {
        grid-template-columns: 1fr;
        grid-template-rows: auto 1fr;
    }
    
    .truck-columns {
        grid-template-columns: 1fr;
    }
    
    .header-controls {
        flex-direction: column;
        align-items: stretch;
        gap: 1rem;
    }
    
    .board-actions {
        margin-left: 0;
    }
    
    .truck-actions {
        flex-direction: column;
        gap: 0.25rem;
    }
    
    .truck-action-btn {
        font-size: 0.7rem;
        padding: 0.3rem 0.5rem;
    }
    
    .map-modal-content {
        width: 98%;
        margin: 1rem auto;
        max-height: 95vh;
    }
    
    .map-layout-container {
        flex-direction: column;
        height: auto;
        min-height: auto;
    }
    
    .route-summary-sidebar {
        width: 100%;
        min-width: auto;
        max-height: 200px;
        order: 2;
    }
    
    .map-main-area {
        order: 1;
    }
    
    #truck-map {
        height: 300px !important;
    }
}

/* Drive time boxes for routing */
.drive-time-box {
    background: linear-gradient(135deg, #f8f9fa, #e9ecef);
    border: 2px solid #dee2e6;
    border-radius: 8px;
    margin: 0.5rem 0;
    padding: 0.75rem;
    transition: all 0.3s ease;
}

.drive-time-box:hover {
    border-color: #2c5aa0;
    box-shadow: 0 2px 8px rgba(44, 90, 160, 0.15);
}

.drive-time-content {
    display: flex;
    align-items: center;
    gap: 0.75rem;
}

.drive-time-icon {
    font-size: 1.5rem;
    flex-shrink: 0;
}

.drive-time-details {
    flex: 1;
}

.drive-time-duration {
    font-size: 1.1rem;
    font-weight: bold;
    color: #2c5aa0;
    margin-bottom: 0.25rem;
}

.drive-time-distance {
    font-size: 0.9rem;
    color: #666;
    margin-bottom: 0.25rem;
}

.drive-time-route {
    font-size: 0.8rem;
    color: #888;
    font-style: italic;
}

/* Special styling for start/end drive time boxes */
.drive-time-box.drive-time-start {
    background: linear-gradient(135deg, #e3f2fd, #bbdefb);
    border-color: #2196f3;
}

.drive-time-box.drive-time-start:hover {
    border-color: #1976d2;
    box-shadow: 0 2px 8px rgba(33, 150, 243, 0.2);
}

.drive-time-box.drive-time-end {
    background: linear-gradient(135deg, #f3e5f5, #e1bee7);
    border-color: #9c27b0;
}

.drive-time-box.drive-time-end:hover {
    border-color: #7b1fa2;
    box-shadow: 0 2px 8px rgba(156, 39, 176, 0.2);
}

.drive-time-start .drive-time-duration {
    color: #1976d2;
}

.drive-time-end .drive-time-duration {
    color: #7b1fa2;
}
</style>

<!-- Leaflet JavaScript -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" 
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

<script>
console.log('üîÑ JOB BOARD LOADED - CHECK FOR DRAG DROP FIX');
// Global variables
let currentDate = new Date().toISOString().split('T')[0];
let currentTruckId = null;
let trucks = [];
let teamAssignments = {};
let allPendingTickets = []; // Store all pending tickets for search functionality
let currentSearchTerm = '';
let currentSortBy = 'oldest';

// Click vs Drag detection
let mouseDownTime = 0;
let mouseDownPos = {x: 0, y: 0};
let isDragging = false;

document.addEventListener('DOMContentLoaded', function() {
    console.log('üéØ TrueTank Job Board Loaded - Console is working!');
    console.log('üîç Checking for ticket elements...');
    
    // Debug: Check what elements exist
    setTimeout(() => {
        const pendingTickets = document.querySelectorAll('#pending-tickets .ticket-card');
        const truckTickets = document.querySelectorAll('.truck-column .ticket-card-compact');
        console.log('üìä Found pending tickets:', pendingTickets.length);
        console.log('üìä Found truck tickets:', truckTickets.length);
        
        // Test draggable attribute
        if (pendingTickets.length > 0) {
            const firstTicket = pendingTickets[0];
            console.log('üé™ First pending ticket draggable:', firstTicket.draggable);
            console.log('üé™ First pending ticket dataset:', firstTicket.dataset);
        }
    }, 1000);
    
    // Initialize date picker with today's date
    document.getElementById('selected-date').value = currentDate;
    
    // Event listeners
    document.getElementById('selected-date').addEventListener('change', function() {
        currentDate = this.value;
        loadJobBoard();
    });
    
    document.getElementById('prev-day').addEventListener('click', function() {
        const date = new Date(currentDate);
        date.setDate(date.getDate() - 1);
        currentDate = date.toISOString().split('T')[0];
        document.getElementById('selected-date').value = currentDate;
        loadJobBoard();
    });
    
    document.getElementById('next-day').addEventListener('click', function() {
        const date = new Date(currentDate);
        date.setDate(date.getDate() + 1);
        currentDate = date.toISOString().split('T')[0];
        document.getElementById('selected-date').value = currentDate;
        loadJobBoard();
    });
    
    document.getElementById('today-btn').addEventListener('click', function() {
        currentDate = new Date().toISOString().split('T')[0];
        document.getElementById('selected-date').value = currentDate;
        loadJobBoard();
    });
    
    document.getElementById('sort-pending').addEventListener('change', function() {
        currentSortBy = this.value;
        loadJobBoard();
    });
    
    document.getElementById('search-pending').addEventListener('input', function() {
        currentSearchTerm = this.value.toLowerCase();
        filterAndDisplayPendingTickets();
    });
    
    
    // Add drag and drop event listeners to pending column
    const pendingList = document.getElementById('pending-tickets');
    pendingList.addEventListener('dragover', handleDragOver);
    pendingList.addEventListener('drop', handleDrop);
    console.log('‚úÖ Added drag/drop listeners to pending list');
    
    // Test: Add document-level dragover listener to see if ANY dragover events fire
    document.addEventListener('dragover', function(e) {
        if (draggedCard) {
            console.log('üìç DOCUMENT dragover on:', e.target.tagName, e.target.className);
        }
    });
    
    // Load initial data
    loadJobBoard();
});

function loadJobBoard() {
    const url = `/api/job-board?date=${currentDate}&sort=${currentSortBy}`;
    
    fetch(url)
        .then(response => response.json())
        .then(data => {
            trucks = data.trucks;
            allPendingTickets = data.pending_tickets;
            currentSortBy = data.sort_by;
            
            // Load persisted team assignments
            teamAssignments = {};
            if (data.team_assignments) {
                Object.keys(data.team_assignments).forEach(truckId => {
                    const assignment = data.team_assignments[truckId];
                    teamAssignments[truckId] = {
                        id: assignment.team_member_id,
                        name: assignment.team_member_name,
                        position: assignment.position,
                        home_address: assignment.home_address
                    };
                });
            }
            
            // Update sort dropdown
            document.getElementById('sort-pending').value = currentSortBy;
            
            // Filter and display pending tickets
            filterAndDisplayPendingTickets();
            
            renderTruckColumns(data.trucks, data.truck_schedules);
            
            // If a truck map is currently open, refresh it with updated data
            if (currentMapTruckId && document.getElementById('truck-map-modal').style.display === 'flex') {
                console.log('Refreshing open map with updated data');
                const truckInfo = trucks.find(t => t.id == currentMapTruckId);
                const assignedTeamMember = teamAssignments[currentMapTruckId];
                const truckTickets = data.truck_schedules[currentMapTruckId] || [];
                
                // Re-initialize the map with fresh data
                initializeMapWithTickets(truckInfo, assignedTeamMember, truckTickets);
            }
        })
        .catch(error => {
            console.error('Error loading job board:', error);
            // Don't show alert, just log the error
        });
}

function filterAndDisplayPendingTickets() {
    let filteredTickets = allPendingTickets;
    
    // Apply search filter
    if (currentSearchTerm) {
        filteredTickets = allPendingTickets.filter(ticket => {
            const searchableText = [
                ticket.job_id,
                ticket.customer_name,
                ticket.service_type,
                ticket.service_description,
                ticket.priority,
                ticket.status
            ].join(' ').toLowerCase();
            
            return searchableText.includes(currentSearchTerm);
        });
    }
    
    renderPendingTickets(filteredTickets);
    updatePendingCount(filteredTickets.length);
}

function renderPendingTickets(tickets) {
    const container = document.getElementById('pending-tickets');
    container.innerHTML = '';
    
    if (tickets.length === 0) {
        const noResults = document.createElement('div');
        noResults.className = 'no-results';
        noResults.textContent = currentSearchTerm ? 'No tickets match your search' : 'No pending tickets';
        container.appendChild(noResults);
        return;
    }
    
    tickets.forEach(ticket => {
        const ticketCard = createTicketCard(ticket);
        container.appendChild(ticketCard);
    });
}

function renderTruckColumns(trucks, schedules) {
    const container = document.getElementById('truck-columns');
    container.innerHTML = '';
    
    trucks.forEach(truck => {
        const column = createTruckColumn(truck, schedules[truck.id] || []);
        container.appendChild(column);
    });
}

function createTicketCard(ticket, context = 'pending') {
    const card = document.createElement('div');
    card.dataset.ticketId = ticket.id;
    card.dataset.context = context;
    
    if (context === 'truck') {
        // Compact truck view - thinner card with just job ID and service type
        card.className = `ticket-card-compact priority-${ticket.priority}`;
        card.setAttribute('draggable', 'true'); // Enable dragging for truck tickets
        console.log('Created truck card with draggable:', card.draggable);
        card.innerHTML = `
            <div class="compact-header">
                <span class="compact-customer-name">${ticket.customer_name || 'No Customer'}</span>
                <button class="btn-compact-action" onclick="event.stopPropagation(); moveTicketToPending(${ticket.id})" title="Move back to Pending">‚Üê</button>
            </div>
            <div class="compact-service">${ticket.service_type || 'Service'}</div>
        `;
        // Add drag event listeners for truck tickets
        card.addEventListener('dragstart', function(e) {
            console.log('Drag start - truck ticket:', card.dataset.ticketId);
            handleDragStart(e);
        });
        card.addEventListener('dragend', function(e) {
            console.log('Drag end - truck ticket:', card.dataset.ticketId);
            handleDragEnd(e);
        });
        console.log('Added drag listeners to truck card:', card.dataset.ticketId);
        // Add click handler for expansion
        card.addEventListener('mousedown', handleCardMouseDown);
        card.addEventListener('mouseup', handleCardMouseUp);
        card.addEventListener('click', handleCardClick);
    } else {
        // Full pending view - detailed card with all information
        card.className = `ticket-card priority-${ticket.priority}`;
        card.setAttribute('draggable', 'true'); // Enable dragging for pending tickets to assign to trucks
        console.log('Created pending card with draggable:', card.draggable);
        
        let dueDate = '';
        if (ticket.requested_service_date) {
            const due = new Date(ticket.requested_service_date);
            dueDate = `<div class="ticket-due">Due: ${due.toLocaleDateString()}</div>`;
        }
        
        card.innerHTML = `
            <div class="pending-header">
                <span class="pending-job-id">${ticket.job_id}</span>
                <span class="priority-badge priority-${ticket.priority}">${ticket.priority}</span>
            </div>
            <div class="pending-customer">${ticket.customer_name || 'No customer'}</div>
            <div class="pending-address">${ticket.customer_address || 'No address'}</div>
            <div class="pending-service">${ticket.service_type || 'No service type'}</div>
            ${dueDate}
        `;
        // Add drag event listeners for pending tickets
        card.addEventListener('dragstart', function(e) {
            console.log('Drag start - pending ticket:', card.dataset.ticketId);
            handleDragStart(e);
        });
        card.addEventListener('dragend', function(e) {
            console.log('Drag end - pending ticket:', card.dataset.ticketId);
            handleDragEnd(e);
        });
        console.log('Added drag listeners to pending card:', card.dataset.ticketId);
        // Add click handler for expansion
        card.addEventListener('mousedown', handleCardMouseDown);
        card.addEventListener('mouseup', handleCardMouseUp);
        card.addEventListener('click', handleCardClick);
    }
    
    return card;
}

function createTruckColumn(truck, tickets) {
    const column = document.createElement('div');
    column.className = 'truck-column';
    column.dataset.truckId = truck.id;
    
    const assignedMember = teamAssignments[truck.id] || null;
    const teamDisplay = assignedMember ? 
        `Assigned: ${assignedMember.name}` : 
        'Click to assign team member';
    
    column.innerHTML = `
        <div class="truck-header">
            <div class="truck-title-section">
                <h4>${truck.truck_number}</h4>
                <div class="truck-info">${truck.make} ${truck.model}</div>
            </div>
            <div class="truck-actions">
                <button class="truck-action-btn map-btn" onclick="openTruckMap(${truck.id}, '${truck.truck_number}')" title="Plan route">
                    üìã Plan
                </button>
            </div>
        </div>
        <div class="team-assignment" onclick="openTeamModal(${truck.id}, '${truck.truck_number}')" style="cursor: pointer;">${teamDisplay}</div>
        <div class="ticket-list" 
             data-truck-id="${truck.id}">
            ${tickets.length === 0 ? '<div class="drop-zone">Drop tickets here</div>' : ''}
        </div>
    `;
    
    // Add existing tickets
    const ticketList = column.querySelector('.ticket-list');
    console.log(`üöõ Truck ${truck.id} tickets in order:`, tickets.map(t => `${t.id}(pos:${t.route_position})`));
    tickets.forEach((ticket, index) => {
        const ticketCard = createTicketCard(ticket, 'truck');
        ticketCard.dataset.routePosition = ticket.route_position || index;
        console.log(`üìç Adding ticket ${ticket.id} at DOM position ${index}, route_position: ${ticket.route_position}`);
        ticketList.appendChild(ticketCard);
    });
    
    // Add event listeners for drag and drop
    ticketList.addEventListener('dragover', handleDragOver);
    ticketList.addEventListener('drop', handleDrop);
    console.log('‚úÖ Added drag/drop listeners to truck list:', truck.id);
    
    return column;
}

function updatePendingCount(count) {
    document.getElementById('pending-count').textContent = count;
}

// Clean Drag and Drop - Simple and Precise
let draggedCard = null;
let mouseCard = null;
let dropPlaceholder = null;
let dropPosition = 0;

// Start dragging
function handleDragStart(e) {
    console.log('handleDragStart called');
    const card = e.target.closest('.ticket-card, .ticket-card-compact');
    if (!card) {
        console.log('No card found in handleDragStart');
        return;
    }
    
    console.log('Setting draggedCard to:', card.dataset.ticketId);
    draggedCard = card;
    
    // Set drag data first
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/plain', card.dataset.ticketId);
    
    // Delay removing the card from layout to allow drag to initialize
    setTimeout(() => {
        if (draggedCard) {
            draggedCard.style.position = 'absolute';
            draggedCard.style.top = '-9999px';
            draggedCard.style.left = '-9999px';
            draggedCard.style.zIndex = '-1';
            draggedCard.classList.add('dragging');
            
            // Animate remaining cards sliding up to fill space
            animateCardsAfterRemoval(draggedCard);
            
            console.log('Removed card from layout during drag');
        }
    }, 50);
    
    console.log('Drag start completed');
}

// Update mouse-following card position
function updateMouseCard(e) {
    if (mouseCard) {
        mouseCard.style.left = (e.clientX - mouseCard.offsetWidth / 2) + 'px';
        mouseCard.style.top = (e.clientY - 20) + 'px';
    }
}

// Handle drag over
function handleDragOver(e) {
    console.log('üåä DRAGOVER EVENT FIRED on:', e.target.tagName, e.target.className);
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    
    if (!draggedCard) {
        console.log('‚ùå No draggedCard in dragover');
        return;
    }
    
    // Add visual feedback to show valid drop zones
    const targetList = e.target.closest('.ticket-list');
    if (!targetList) {
        console.log('‚ùå No .ticket-list found, target was:', e.target.tagName, e.target.className);
        removePlaceholder();
        return;
    }
    
    targetList.style.backgroundColor = 'rgba(52, 152, 219, 0.1)';
    console.log('‚úÖ Over valid drop zone:', targetList.dataset.truckId || 'pending');
    
    const truckColumn = targetList.closest('.truck-column');
    const pendingColumn = targetList.closest('.pending-column');
    const sourceIsPending = draggedCard.closest('.pending-column');
    
    // Don't allow dropping in pending if already from pending
    if (pendingColumn && sourceIsPending) {
        removePlaceholder();
        return;
    }
    
    // Only show placeholder in truck columns
    if (truckColumn) {
        console.log('üöõ Dragging over TRUCK column:', truckColumn.dataset.truckId);
        showDropPlaceholder(e, targetList);
    } else {
        console.log('üìù Dragging over PENDING column or other');
        removePlaceholder();
    }
}

// Show drop placeholder
function showDropPlaceholder(e, targetList) {
    // Remove existing placeholder first to avoid counting it
    removePlaceholder();
    
    // Exclude the dragged card and any existing placeholders from position calculation
    const tickets = Array.from(targetList.querySelectorAll('.ticket-card-compact:not(.dragging)'))
        .filter(card => card.dataset.ticketId !== draggedCard.dataset.ticketId && !card.classList.contains('drop-placeholder'));
    const mouseY = e.clientY;
    
    console.log(`üéØ Position calc: ${tickets.length} tickets (excluding dragged: ${draggedCard.dataset.ticketId})`);
    console.log(`üéØ Tickets found:`, tickets.map(t => t.dataset.ticketId));
    console.log(`üéØ Mouse Y: ${mouseY}`);
    
    // Find drop position
    dropPosition = 0;
    let insertBefore = null;
    
    for (let i = 0; i < tickets.length; i++) {
        const rect = tickets[i].getBoundingClientRect();
        const midPoint = rect.top + rect.height / 2;
        console.log(`üìè Ticket ${tickets[i].dataset.ticketId}: top=${rect.top}, bottom=${rect.bottom}, midPoint=${midPoint}, mouseY=${mouseY}`);
        
        if (mouseY < midPoint) {
            dropPosition = i;
            insertBefore = tickets[i];
            console.log(`üìç Inserting at position ${i} (before ticket ${tickets[i].dataset.ticketId})`);
            break;
        }
        dropPosition = i + 1;
    }
    
    if (insertBefore === null) {
        console.log(`üìç Inserting at end (position ${dropPosition})`);
    }
    
    // Create new placeholder
    dropPlaceholder = document.createElement('div');
    dropPlaceholder.className = 'drop-placeholder';
    dropPlaceholder.textContent = 'Drop card here';
    
    // Match the size of compact cards
    const sampleCard = targetList.querySelector('.ticket-card-compact');
    if (sampleCard) {
        dropPlaceholder.style.height = sampleCard.offsetHeight + 'px';
    }
    
    // Insert placeholder
    if (insertBefore) {
        targetList.insertBefore(dropPlaceholder, insertBefore);
    } else {
        targetList.appendChild(dropPlaceholder);
    }
    
    // Animate cards that come after the placeholder
    animateCardsOnPlaceholder();
    
    // Store position for drop
    targetList.dataset.dropPosition = dropPosition;
}

// Remove placeholder
function removePlaceholder() {
    if (dropPlaceholder) {
        dropPlaceholder.remove();
        dropPlaceholder = null;
    }
}

// Handle drop
function handleDrop(e) {
    e.preventDefault();
    console.log('üéØ DROP EVENT TRIGGERED!');
    
    if (!draggedCard) {
        console.log('‚ùå No dragged card found');
        return;
    }
    console.log('‚úÖ Dragged card found:', draggedCard.dataset.ticketId);
    
    const targetList = e.target.closest('.ticket-list');
    if (!targetList) {
        console.log('‚ùå No target list found for drop - target was:', e.target.tagName, e.target.className);
        return;
    }
    console.log('‚úÖ Target list found for drop');
    
    const truckColumn = targetList.closest('.truck-column');
    const pendingColumn = targetList.closest('.pending-column');
    const sourceIsPending = draggedCard.closest('.pending-column');
    const sourceTruckColumn = draggedCard.closest('.truck-column');
    
    const ticketId = draggedCard.dataset.ticketId;
    
    if (truckColumn) {
        const truckId = truckColumn.dataset.truckId;
        const sourceTruckId = sourceTruckColumn?.dataset.truckId;
        const position = parseInt(targetList.dataset.dropPosition || '0');
        
        console.log(`üéØ DROP: ticket ${ticketId}, sourceTruck: ${sourceTruckId}, targetTruck: ${truckId}, position: ${position}`);
        
        if (sourceTruckId === truckId) {
            // Reordering within same truck
            console.log(`üîÑ REORDERING within truck ${truckId} at position ${position}`);
            reorderTicketInTruck(ticketId, truckId, position);
        } else {
            // Moving from pending or different truck
            console.log(`‚û°Ô∏è ASSIGNING to truck ${truckId} at position ${position}`);
            assignTicketToTruck(ticketId, truckId, position);
        }
    } else if (pendingColumn && !sourceIsPending) {
        // Moving back to pending from a truck
        moveTicketToPending(ticketId);
    }
}

// Clean up after drag
function handleDragEnd(e) {
    console.log('handleDragEnd called');
    // Restore original card appearance
    if (draggedCard) {
        draggedCard.style.position = '';
        draggedCard.style.top = '';
        draggedCard.style.left = '';
        draggedCard.style.zIndex = '';
        draggedCard.classList.remove('dragging');
        draggedCard = null;
        console.log('Restored card to layout');
    }
    
    // Remove visual feedback from all drop zones
    document.querySelectorAll('.ticket-list').forEach(list => {
        list.style.backgroundColor = '';
    });
    
    // Remove placeholder
    removePlaceholder();
    
    dropPosition = 0;
}

// Removed mouse tracking since we're using simpler drag approach

function assignTicketToTruck(ticketId, truckId, routePosition) {
    const data = {
        ticket_id: ticketId,
        truck_id: truckId,
        scheduled_date: new Date(currentDate + 'T09:00:00').toISOString(),
        route_position: routePosition
    };
    
    fetch('/api/tickets/assign', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(data)
    })
    .then(response => response.json())
    .then(result => {
        if (result.success) {
            loadJobBoard(); // Refresh the entire board
        } else {
            alert('Error assigning ticket: ' + result.error);
        }
    })
    .catch(error => {
        console.error('Error:', error);
        alert('Failed to assign ticket');
    });
}

function reorderTicketInTruck(ticketId, truckId, newPosition) {
    console.log('Frontend sending position:', newPosition, 'for ticket:', ticketId);
    const data = {
        ticket_id: ticketId,
        truck_id: truckId,
        route_position: newPosition,
        scheduled_date: new Date(currentDate + 'T09:00:00').toISOString()
    };
    
    fetch('/api/tickets/reorder-route', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(data)
    })
    .then(response => response.json())
    .then(result => {
        if (result.success) {
            loadJobBoard(); // Refresh the entire board
        } else {
            alert('Error reordering ticket: ' + result.error);
        }
    })
    .catch(error => {
        console.error('Error:', error);
        alert('Failed to reorder ticket');
    });
}

function moveTicketToPending(ticketId) {
    const data = {
        ticket_id: ticketId,
        truck_id: null,
        scheduled_date: null,
        route_position: null
    };
    
    fetch('/api/tickets/assign', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(data)
    })
    .then(response => response.json())
    .then(result => {
        if (result.success) {
            loadJobBoard(); // Refresh the entire board
        } else {
            alert('Error moving ticket to pending: ' + result.error);
        }
    })
    .catch(error => {
        console.error('Error:', error);
        alert('Failed to move ticket to pending');
    });
}

// Team Assignment Functions
function openTeamModal(truckId, truckNumber) {
    currentTruckId = truckId;
    document.getElementById('modal-truck-name').textContent = truckNumber;
    document.getElementById('modal-date').textContent = new Date(currentDate).toLocaleDateString();
    
    // Pre-select current assignment
    const teamSelect = document.getElementById('team-member-select');
    if (teamAssignments[truckId]) {
        teamSelect.value = teamAssignments[truckId].id;
    } else {
        teamSelect.value = '';
    }
    
    document.getElementById('team-assignment-modal').style.display = 'block';
}

function closeTeamModal() {
    document.getElementById('team-assignment-modal').style.display = 'none';
    currentTruckId = null;
}

function saveTeamAssignment() {
    const memberId = document.getElementById('team-member-select').value;
    const memberName = document.getElementById('team-member-select').selectedOptions[0].text;
    
    if (currentTruckId) {
        // Save to database
        const assignmentData = {
            truck_id: currentTruckId,
            team_member_id: memberId || null,
            assignment_date: currentDate
        };
        
        fetch('/api/team-assignments', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(assignmentData)
        })
        .then(response => response.json())
        .then(result => {
            if (result.success) {
                // Update local cache
                if (memberId) {
                    teamAssignments[currentTruckId] = {
                        id: memberId,
                        name: memberName
                    };
                } else {
                    delete teamAssignments[currentTruckId];
                }
                
                // Update the display
                const truckColumn = document.querySelector(`[data-truck-id="${currentTruckId}"]`);
                const teamDisplay = teamAssignments[currentTruckId] ? 
                    `Assigned: ${teamAssignments[currentTruckId].name}` : 
                    'Click to assign team member';
                truckColumn.querySelector('.team-assignment').textContent = teamDisplay;
                
                closeTeamModal();
            } else {
                alert('Error saving team assignment: ' + result.error);
            }
        })
        .catch(error => {
            console.error('Error:', error);
            alert('Failed to save team assignment');
        });
    }
}

// Click vs Drag Detection Functions
function handleCardMouseDown(e) {
    mouseDownTime = Date.now();
    mouseDownPos = {x: e.clientX, y: e.clientY};
    isDragging = false;
}

function handleCardMouseUp(e) {
    const timeDiff = Date.now() - mouseDownTime;
    const distance = Math.sqrt(
        Math.pow(e.clientX - mouseDownPos.x, 2) + 
        Math.pow(e.clientY - mouseDownPos.y, 2)
    );
    
    // If it was a short time and small movement, treat as click
    isDragging = timeDiff > 200 || distance > 10;
}

function handleCardClick(e) {
    // Don't trigger click if it was a drag operation
    if (isDragging) {
        return;
    }
    
    // Don't trigger if clicking on action buttons
    if (e.target.classList.contains('btn-compact-action') || 
        e.target.classList.contains('priority-badge')) {
        return;
    }
    
    const ticketId = e.currentTarget.dataset.ticketId;
    
    // Navigate directly to the ticket detail page
    window.location.href = `/ticket/${ticketId}`;
}

// Truck Map Functions
let currentMapTruckId = null;
let truckMap = null;
let mapMarkers = [];

// Global variables to track map markers for navigation
let jobMarkers = new Map(); // Map ticket ID to marker
let currentNavigationTicket = null;

function navigateToTicketOnMap(ticket) {
    console.log('üß≠ Navigating to ticket on map:', ticket.job_id);
    
    // If ticket is assigned to a truck, open that truck's map
    if (ticket.truck_id) {
        const truck = trucks.find(t => t.id === ticket.truck_id);
        if (truck) {
            console.log('üìç Opening map for truck:', truck.truck_number);
            currentNavigationTicket = ticket;
            openTruckMap(ticket.truck_id, truck.truck_number);
            return;
        }
    }
    
    // If ticket is not assigned, suggest assigning it first
    console.log('‚ö†Ô∏è Ticket not assigned to any truck yet');
    showToast('Please assign this ticket to a truck first to see it on the map', 'warning');
}

function highlightTicketOnMapWithData(ticket) {
    console.log('üéØ Highlighting ticket on map using original data:', ticket.id);
    
    // Use the original coordinates from the ticket data
    let coords;
    if (ticket.customer_gps_coordinates) {
        const [lat, lng] = ticket.customer_gps_coordinates.split(',');
        coords = [parseFloat(lat), parseFloat(lng)];
        console.log('Using GPS coordinates:', coords);
    } else {
        // Fall back to generated coordinates if no GPS data
        coords = generateCoordinatesForAddress(ticket.customer_address || '', 0);
        console.log('Using generated coordinates:', coords);
    }
    
    const targetLatLng = L.latLng(coords[0], coords[1]);
    console.log('Snapping map to coordinates:', targetLatLng);
    
    // Snap directly to the coordinates with no animation
    truckMap.setView(targetLatLng, 16);
    
    // Find and highlight the marker
    const marker = jobMarkers.get(ticket.id);
    if (marker) {
        // Temporarily highlight the marker
        const originalIcon = marker.getIcon();
        
        // Create highlighted icon
        marker.setIcon(L.divIcon({
            className: 'job-marker-highlight',
            html: `<div style="background: #ff4444; color: white; border-radius: 50%; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 4px solid white; box-shadow: 0 0 20px rgba(255,68,68,0.6); font-size: 16px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; animation: pulse 2s infinite;">üéØ</div>`,
            iconSize: [40, 40],
            iconAnchor: [20, 20]
        }));
        
        // Reset the icon after 3 seconds
        setTimeout(() => {
            marker.setIcon(originalIcon);
        }, 3000);
        
        // Show popup with ticket info
        marker.openPopup();
    }
}

function highlightTicketOnMap(ticketId) {
    console.log('üéØ Highlighting ticket on map:', ticketId);
    
    // Find the marker for this ticket
    const marker = jobMarkers.get(ticketId);
    if (marker && truckMap) {
        const markerLatLng = marker.getLatLng();
        console.log('Centering map on coordinates:', markerLatLng);
        
        // Simply center the map on the marker coordinates
        truckMap.setView(markerLatLng, 16, {
            animate: true,
            duration: 1.0
        });
        
        // Temporarily highlight the marker
        const originalIcon = marker.getIcon();
        
        // Create highlighted icon
        marker.setIcon(L.divIcon({
            className: 'job-marker-highlight',
            html: `<div style="background: #ff4444; color: white; border-radius: 50%; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 4px solid white; box-shadow: 0 0 20px rgba(255,68,68,0.6); font-size: 16px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; animation: pulse 2s infinite;">üéØ</div>`,
            iconSize: [40, 40],
            iconAnchor: [20, 20]
        }));
        
        // Reset the icon after 3 seconds
        setTimeout(() => {
            marker.setIcon(originalIcon);
        }, 3000);
        
        // Show popup with ticket info
        marker.openPopup();
    }
}

function showToast(message, type = 'info') {
    // Create toast notification
    const toast = document.createElement('div');
    toast.className = `toast toast-${type}`;
    toast.textContent = message;
    
    // Style the toast
    Object.assign(toast.style, {
        position: 'fixed',
        top: '20px',
        right: '20px',
        padding: '12px 16px',
        borderRadius: '4px',
        color: 'white',
        fontSize: '14px',
        zIndex: '10000',
        maxWidth: '300px',
        backgroundColor: type === 'warning' ? '#f39c12' : type === 'error' ? '#e74c3c' : '#3498db'
    });
    
    document.body.appendChild(toast);
    
    // Remove after 3 seconds
    setTimeout(() => {
        if (toast.parentNode) {
            toast.parentNode.removeChild(toast);
        }
    }, 3000);
}

function openTruckMap(truckId, truckNumber) {
    console.log('Opening truck map for:', truckNumber, 'ID:', truckId);
    currentMapTruckId = truckId;
    
    // Update modal title and date
    document.getElementById('map-truck-name').textContent = truckNumber;
    document.getElementById('summary-date').textContent = currentDate;
    
    // Show modal
    document.getElementById('truck-map-modal').style.display = 'flex';
    
    // Initialize map with longer delay to ensure modal is visible
    setTimeout(() => {
        console.log('Initializing map...');
        try {
            initializeTruckMap(truckId);
            
            // If there's a navigation ticket, highlight it after the map is built
            if (currentNavigationTicket && currentNavigationTicket.truck_id === truckId) {
                setTimeout(() => {
                    highlightTicketOnMap(currentNavigationTicket.id);
                    currentNavigationTicket = null; // Reset after use
                }, 1000); // Wait for map to be fully built
            }
        } catch (error) {
            console.error('Error initializing map:', error);
            document.getElementById('truck-map').innerHTML = `
                <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #e74c3c;">
                    <div style="text-align: center;">
                        <div style="font-size: 2rem; margin-bottom: 1rem;">‚ö†Ô∏è</div>
                        <div>Error loading map: ${error.message}</div>
                    </div>
                </div>
            `;
        }
    }, 300);
}

// Global cancellation controller for route calculation
let routeCalculationController = null;

function closeTruckMapModal() {
    document.getElementById('truck-map-modal').style.display = 'none';
    currentMapTruckId = null;
    
    // Cancel any ongoing route calculation
    if (routeCalculationController) {
        console.log('Aborting route calculation...');
        routeCalculationController.abort();
        routeCalculationController = null;
    }
    
    // Clear and remove map
    if (truckMap) {
        truckMap.remove();
        truckMap = null;
        mapMarkers = [];
        jobMarkers.clear(); // Clear navigation markers
    }
}

function initializeTruckMap(truckId) {
    console.log('Initializing truck map for truck ID:', truckId);
    console.log('Available trucks:', trucks);
    console.log('Team assignments:', teamAssignments);
    
    // Get truck info from global trucks array
    const truckInfo = trucks.find(t => t.id == truckId);
    const assignedTeamMember = teamAssignments[truckId];
    
    // Fetch the detailed ticket data for this truck from the API
    fetch(`/api/job-board?date=${currentDate}`)
        .then(response => response.json())
        .then(data => {
            const truckTickets = data.truck_schedules[truckId] || [];
            console.log('Fetched truck tickets:', truckTickets);
            
            // Continue with map initialization
            initializeMapWithTickets(truckInfo, assignedTeamMember, truckTickets);
        })
        .catch(error => {
            console.error('Error fetching ticket data:', error);
            // Fallback to simpler map
            initializeMapWithTickets(truckInfo, assignedTeamMember, []);
        });
}

function initializeMapWithTickets(truckInfo, assignedTeamMember, truckTickets) {
    
    console.log('Truck tickets from database:', truckTickets.length);
    console.log('Truck info:', truckInfo);
    console.log('Assigned team member:', assignedTeamMember);
    
    // Populate sidebar with truck and team information
    populateSidebarInfo(truckInfo, assignedTeamMember);
    
    // Use tickets from database (already sorted by route_position in the API)
    // The API endpoint sorts by route_position which is updated by drag & drop
    const orderedTickets = truckTickets;
    
    console.log('Using database order - tickets are already sorted by route_position:', orderedTickets);
    
    // Clear existing map and markers before reinitializing
    if (truckMap) {
        // Clear all markers
        mapMarkers.forEach(marker => {
            try {
                marker.remove();
            } catch (e) {
                console.error('Error removing marker:', e);
            }
        });
        mapMarkers = [];
        
        // Remove the map instance
        truckMap.remove();
        truckMap = null;
    }
    
    // Clear the map container
    const mapContainer = document.getElementById('truck-map');
    if (!mapContainer) {
        throw new Error('Map container not found');
    }
    mapContainer.innerHTML = '';
    
    // Check if Leaflet is available
    if (typeof L === 'undefined') {
        throw new Error('Leaflet library not loaded');
    }
    
    console.log('Creating Leaflet map...');
    // Initialize Leaflet map centered on Pewee Valley, KY
    truckMap = L.map('truck-map').setView([38.3148, -85.4569], 11);
    
    // Add satellite imagery tiles using Esri World Imagery
    L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
        attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
    }).addTo(truckMap);
    
    // Add road/label overlay on top of satellite imagery for hybrid view
    L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Transportation/MapServer/tile/{z}/{y}/{x}', {
        attribution: ''
    }).addTo(truckMap);
    
    // Add place names and labels overlay
    L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}', {
        attribution: ''
    }).addTo(truckMap);
    
    // Array to track all points for map bounds
    const allPoints = [];
    
    // 1. Add TrueTank Office marker
    const officeCoords = [38.3148, -85.4569];
    const officeMarker = L.marker(officeCoords, {
        icon: L.divIcon({
            className: 'office-marker',
            html: '<div style="background: #27ae60; color: white; border-radius: 8px; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 2px solid white; box-shadow: 0 2px 6px rgba(0,0,0,0.3); font-size: 16px;">üè¢</div>',
            iconSize: [32, 32],
            iconAnchor: [16, 16]
        })
    }).addTo(truckMap);
    
    officeMarker.bindPopup('<b>üè¢ TrueTank Main Office</b><br>123 Main Street<br>Pewee Valley, KY 40056<br><i>Depot & Headquarters</i>');
    mapMarkers.push(officeMarker);
    allPoints.push(officeCoords);
    
    // 2. Add team member home location (if assigned)
    if (assignedTeamMember) {
        const teamMemberCoords = getTeamMemberHomeCoords(assignedTeamMember.name);
        const teamMarker = L.marker(teamMemberCoords, {
            icon: L.divIcon({
                className: 'team-marker',
                html: '<div style="background: #9b59b6; color: white; border-radius: 8px; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 2px solid white; box-shadow: 0 2px 6px rgba(0,0,0,0.3); font-size: 14px;">üë§</div>',
                iconSize: [30, 30],
                iconAnchor: [15, 15]
            })
        }).addTo(truckMap);
        
        teamMarker.bindPopup(`<b>üë§ ${assignedTeamMember.name}</b><br>Team Member Home<br><i>Assigned to ${truckInfo.truck_number}</i>`);
        mapMarkers.push(teamMarker);
        allPoints.push(teamMemberCoords);
    }
    
    // 3. Add current truck location (equipment storage in Pewee Valley area)  
    const truckCoords = [38.3125, -85.4580]; // Equipment storage location - Pewee Valley area
    const truckMarker = L.marker(truckCoords, {
        icon: L.divIcon({
            className: 'truck-marker',
            html: `<div style="background: #3498db; color: white; border-radius: 8px; width: 36px; height: 30px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 2px solid white; box-shadow: 0 2px 6px rgba(0,0,0,0.3); font-size: 16px;">üöõ</div>`,
            iconSize: [36, 30],
            iconAnchor: [18, 15]
        })
    }).addTo(truckMap);
    
    truckMarker.bindPopup(`<b>üöõ ${truckInfo.truck_number}</b><br>${truckInfo.make} ${truckInfo.model}<br>Equipment Storage<br><i>Current truck location</i>`);
    mapMarkers.push(truckMarker);
    allPoints.push(truckCoords);
    
    // 4. Add job locations for tickets in this truck (numbered by their route_position order from database)
    if (orderedTickets.length > 0) {
        orderedTickets.forEach((ticket, index) => {
            // Use real customer GPS coordinates if available, otherwise generate coordinates
            let coords;
            if (ticket.customer_gps_coordinates) {
                // Parse stored GPS coordinates "latitude,longitude"
                const [lat, lng] = ticket.customer_gps_coordinates.split(',');
                coords = [parseFloat(lat), parseFloat(lng)];
                console.log(`üìç Job ${index + 1} (${ticket.job_id}): Using real GPS coordinates [${coords[0].toFixed(4)}, ${coords[1].toFixed(4)}]`);
            } else {
                // Fallback to address-based coordinate generation
                coords = generateCoordinatesForAddress(ticket.customer_address || '', index);
                console.log(`üìç Job ${index + 1} (${ticket.job_id}): Generated coordinates from address [${coords[0].toFixed(4)}, ${coords[1].toFixed(4)}]`);
            }
            allPoints.push(coords);
            
            // Get priority color for the marker
            const priorityColor = getPriorityColor(ticket.priority);
            
            // Create job marker numbered by position in truck column
            const jobMarker = L.marker(coords, {
                icon: L.divIcon({
                    className: 'job-marker',
                    html: `<div style="background: ${priorityColor}; color: white; border-radius: 50%; width: 34px; height: 34px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 3px solid white; box-shadow: 0 3px 8px rgba(0,0,0,0.4); font-size: 15px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;">${index + 1}</div>`,
                    iconSize: [34, 34],
                    iconAnchor: [17, 17]
                }),
                // Add Z-index to ensure job markers appear on top
                zIndexOffset: 1000
            }).addTo(truckMap);
            
            // Store marker in jobMarkers map for navigation
            jobMarkers.set(ticket.id, jobMarker);
            
            // Create detailed popup content
            const scheduledTime = ticket.scheduled_date ? 
                new Date(ticket.scheduled_date).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}) : 
                'Time TBD';
            
            const popupContent = `
                <div style="min-width: 220px;">
                    <b>üìç Job ${index + 1}: ${scheduledTime}</b><br>
                    <strong>${ticket.job_id}</strong><br>
                    <div style="margin: 8px 0;">
                        <strong>${ticket.service_type}</strong><br>
                        Customer: ${ticket.customer_name || 'Unknown'}<br>
                        Priority: <span style="color: ${priorityColor}; font-weight: bold;">${(ticket.priority || 'medium').toUpperCase()}</span>
                    </div>
                    <div style="font-size: 0.9em; color: #666;">
                        ${ticket.customer_address || 'Address not available'}<br>
                        Duration: ${ticket.estimated_duration || 'TBD'} min
                    </div>
                </div>
            `;
            
            try {
                jobMarker.bindPopup(popupContent);
                mapMarkers.push(jobMarker);
            } catch (e) {
                console.error('Error binding popup to marker:', e);
            }
        });
        
        // Create route summary with the ordered tickets
        createRouteSummary(orderedTickets);
    } else {
        document.getElementById('route-jobs-list').innerHTML = '<p>No jobs scheduled for this truck today.</p>';
    }
    
    // Fit map to show all points
    if (allPoints.length > 0) {
        const group = new L.featureGroup(mapMarkers.filter(marker => marker.getLatLng));
        truckMap.fitBounds(group.getBounds().pad(0.1));
    }
}

function getTeamMemberHomeCoords(memberName) {
    // Simulate team member home locations around the area
    const teamHomes = {
        'James Wilson': [38.3148, -85.4469],      // Pewee Valley
        'Maria Garcia': [38.2542, -85.7285],      // Louisville  
        'Robert Smith': [38.4048, -85.3716],      // LaGrange
        'Ashley Johnson': [38.3414, -85.4694]     // Crestwood
    };
    
    return teamHomes[memberName] || [38.3148, -85.4569]; // Default to office
}

function generateCoordinatesForAddress(address, index) {
    // Improved geocoding simulation using real Louisville street coordinates
    // This provides more accurate positioning for common Louisville addresses
    
    if (!address) {
        return [38.2527, -85.7585]; // Default Louisville downtown
    }
    
    // Specific street coordinate mappings for Louisville area
    const streetCoordinates = {
        // Downtown Louisville
        '200 S 5th St': [38.2516, -85.7594],
        '400 W Liberty St': [38.2556, -85.7623],
        '800 W Main St': [38.2540, -85.7671],
        
        // South Louisville
        '1900 S 3rd St': [38.2347, -85.7563],
        '2300 Bardstown Rd': [38.2385, -85.7203],
        '1200 Bardstown Rd': [38.2448, -85.7298],
        
        // East Louisville
        '4600 Outer Loop': [38.2156, -85.6834],
        '3200 Poplar Level Rd': [38.2089, -85.7012],
        
        // West Louisville  
        '1000 River Rd': [38.2689, -85.7923],
        '2400 W Broadway': [38.2597, -85.7934],
        
        // St. Matthews area
        '4800 Shelbyville Rd': [38.2524, -85.6234],
        '120 Sears Ave': [38.2587, -85.6345],
        
        // Highlands area
        '1500 Bardstown Rd': [38.2423, -85.7234],
        '2000 Frankfort Ave': [38.2689, -85.7345],
        
        // Okolona/South End
        '5600 Dixie Hwy': [38.1834, -85.7923],
        '7200 Preston Hwy': [38.1689, -85.7234]
    };
    
    // First, try to find exact street match
    for (const [street, coords] of Object.entries(streetCoordinates)) {
        if (address.includes(street.split(' ').slice(1).join(' '))) { // Match street name without number
            // Add small random offset for different addresses on same street
            const offset = 0.001; // About 100 meters
            return [
                coords[0] + (Math.random() - 0.5) * offset,
                coords[1] + (Math.random() - 0.5) * offset
            ];
        }
        // Also try exact address match
        if (address.includes(street)) {
            return [...coords];
        }
    }
    
    // If no exact match, use area-based coordinates with proper Louisville bounds
    const cityCoordinates = {
        'Louisville': [38.2527, -85.7585],
        'Pewee Valley': [38.3148, -85.4569],
        'LaGrange': [38.4048, -85.3816],
        'Crestwood': [38.3414, -85.4794],
        'Buckner': [38.3503, -85.4630],
        'Prospect': [38.3542, -85.5996],
        'Goshen': [38.4014, -85.5691],
        'Ballardsville': [38.3592, -85.5691]
    };
    
    // Find city in address
    let coords = [38.2527, -85.7585]; // Default to Louisville downtown
    
    for (const [city, cityCoords] of Object.entries(cityCoordinates)) {
        if (address.toLowerCase().includes(city.toLowerCase())) {
            coords = [...cityCoords];
            break;
        }
    }
    
    // For Louisville addresses, try to place them in appropriate areas based on street names
    if (address.toLowerCase().includes('louisville')) {
        if (address.includes('Bardstown Rd') || address.includes('Bardstown Road')) {
            coords = [38.2385, -85.7203]; // Bardstown Road corridor
        } else if (address.includes('Dixie Hwy') || address.includes('Dixie Highway')) {
            coords = [38.1934, -85.7923]; // Dixie Highway corridor
        } else if (address.includes('Preston Hwy') || address.includes('Preston Highway')) {
            coords = [38.1889, -85.7234]; // Preston Highway corridor
        } else if (address.includes('Shelbyville Rd') || address.includes('Shelbyville Road')) {
            coords = [38.2524, -85.6234]; // Shelbyville Road corridor
        } else if (address.includes('Outer Loop')) {
            coords = [38.2156, -85.6834]; // Outer Loop area
        } else if (address.includes('Main St') || address.includes('W Main')) {
            coords = [38.2540, -85.7671]; // Main Street corridor
        } else if (address.includes('Broadway')) {
            coords = [38.2597, -85.7934]; // Broadway corridor
        }
    }
    
    // Add realistic random offset within neighborhood (about 0.5 miles)
    const offset = 0.005;
    coords[0] += (Math.random() - 0.5) * offset;
    coords[1] += (Math.random() - 0.5) * offset;
    
    return coords;
}

function getPriorityColor(priority) {
    switch (priority) {
        case 'urgent': return '#e74c3c';
        case 'high': return '#f39c12';
        case 'medium': return '#3498db';
        case 'low': return '#95a5a6';
        default: return '#3498db';
    }
}

function calculateTankFillProgression(tickets) {
    // Get current truck info for capacity calculations
    const truckInfo = getCurrentTruckInfo();
    const maxCapacity = truckInfo?.tank_capacity || 3000;
    const currentLevel = truckInfo?.current_tank_level || 0;
    const dumpThreshold = truckInfo?.tank_full_threshold || 0.8;
    
    let runningLevel = currentLevel;
    const progression = [];
    
    tickets.forEach((ticket, index) => {
        const isDumpStop = ticket.service_type === 'Waste Disposal' || (ticket.job_id && ticket.job_id.startsWith('DUMP-'));
        
        let gallonsDumped = 0;
        
        if (isDumpStop) {
            // Store how much is being dumped (current level before dump)
            gallonsDumped = runningLevel;
            // Dump stop - reset tank level
            runningLevel = 0;
        } else {
            // Regular job - add estimated gallons
            const estimatedGallons = ticket.estimated_gallons || 250; // Default estimate
            runningLevel += estimatedGallons;
        }
        
        const fillPercentage = Math.min(100, (runningLevel / maxCapacity) * 100);
        const isNearFull = fillPercentage >= (dumpThreshold * 100);
        const isOverfull = fillPercentage > (dumpThreshold * 100);
        
        progression.push({
            index,
            gallons: Math.round(runningLevel),
            gallonsDumped: Math.round(gallonsDumped), // Add this for dump stops
            percentage: Math.round(fillPercentage),
            isNearFull,
            isOverfull
        });
    });
    
    return progression;
}

function getCurrentTruckInfo() {
    console.log('Getting truck info for currentMapTruckId:', currentMapTruckId);
    
    // Try to get truck info from the global truck data if available
    if (window.currentTruckData) {
        console.log('Using window.currentTruckData:', window.currentTruckData);
        return window.currentTruckData;
    }
    
    // Try to get from the current truck ID and fetch it
    if (currentMapTruckId) {
        // Find truck in the trucks array
        console.log('Available trucks:', trucks);
        const truck = trucks?.find(t => t.id == currentMapTruckId);
        if (truck) {
            console.log('Found truck in trucks array:', truck);
            return truck;
        }
    }
    
    // Fallback to extracting from the UI
    const capacityElement = document.getElementById('truck-capacity-gallons');
    const currentLevelElement = document.getElementById('tank-current-gallons');
    
    const fallback = {
        tank_capacity: capacityElement ? parseInt(capacityElement.textContent) : 3000,
        current_tank_level: currentLevelElement ? parseInt(currentLevelElement.textContent) : 0,
        tank_full_threshold: 0.8
    };
    
    console.log('Using fallback truck info:', fallback);
    return fallback;
}

function createRouteSummary(tickets) {
    const routeJobsList = document.getElementById('route-jobs-list');
    
    if (tickets.length === 0) {
        routeJobsList.innerHTML = '<p>No jobs scheduled for this date.</p>';
        return;
    }
    
    routeJobsList.innerHTML = '';
    
    // Remove existing event listeners to avoid duplicates
    routeJobsList.removeEventListener('dragover', handleRouteItemDragOver);
    routeJobsList.removeEventListener('drop', handleRouteItemDrop);
    routeJobsList.removeEventListener('dragenter', handleRouteContainerDragEnter);
    
    // Add drag event listeners to the container
    routeJobsList.addEventListener('dragover', handleRouteItemDragOver);
    routeJobsList.addEventListener('drop', handleRouteItemDrop);
    routeJobsList.addEventListener('dragenter', handleRouteContainerDragEnter);
    
    // Calculate tank fill progression
    const tankProgression = calculateTankFillProgression(tickets);
    
    tickets.forEach((ticket, index) => {
        const scheduledTime = ticket.scheduled_date ? 
            new Date(ticket.scheduled_date).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}) : 
            'Time TBD';
            
        const jobItem = document.createElement('div');
        const isDumpStop = ticket.service_type === 'Waste Disposal' || ticket.job_id.startsWith('DUMP-');
        const tankFill = tankProgression[index];
        
        if (isDumpStop) {
            jobItem.className = `route-job-item route-dump-stop`;
        } else {
            jobItem.className = `route-job-item priority-${ticket.priority || 'medium'}`;
        }
        
        jobItem.draggable = true;
        jobItem.dataset.ticketId = ticket.id;
        jobItem.dataset.routePosition = index;
        jobItem.title = '';
        
        // Create tank fill indicator
        const tankIndicatorClass = tankFill.isOverfull ? 'tank-overfull' : (tankFill.isNearFull ? 'tank-near-full' : 'tank-ok');
        const estimatedGallons = ticket.estimated_gallons || 0;
        const gallonChange = isDumpStop ? -tankFill.gallonsDumped : (estimatedGallons > 0 ? estimatedGallons : 250);
        const gallonText = isDumpStop ? `-${Math.abs(gallonChange)} gal` : `+${gallonChange} gal`;
        const gallonChangeClass = isDumpStop ? 'negative' : 'positive';
        
        // Create tank indicator (different for dumps vs regular jobs)
        let tankIndicator;
        if (isDumpStop) {
            // Dump stops don't need percentage bars since they're always 0% after dumping
            tankIndicator = `
                <div class="tank-fill-indicator dump-indicator">
                    <span class="tank-gallons-change ${gallonChangeClass}">${gallonText}</span>
                </div>
            `;
        } else {
            // Regular jobs show tank fill progression
            const fillPercentage = Math.min(100, tankFill.percentage);
            const gradient = generateTankGradient(fillPercentage);
            
            tankIndicator = `
                <div class="tank-fill-indicator ${tankIndicatorClass}">
                    <div class="tank-fill-bar">
                        <div class="tank-fill-level" style="width: ${fillPercentage}%; background: ${gradient}"></div>
                    </div>
                    <span class="tank-fill-text">${tankFill.percentage}%</span>
                    <span class="tank-gallons-change ${gallonChangeClass}">${gallonText}</span>
                </div>
            `;
        }
        
        if (isDumpStop) {
            jobItem.innerHTML = `
                <button class="dump-delete-btn" onclick="removeDumpCard('${ticket.id}')" title="Remove dump stop">√ó</button>
                <div class="job-order dump-order">üóëÔ∏è</div>
                <div class="job-details dump-details">
                    <div>
                        <span class="job-time">${scheduledTime}</span>
                        <span class="job-service dump-service">Tank Dump</span>
                        <span class="job-customer dump-location">${ticket.disposal_location || 'Dump Site'}</span>
                    </div>
                    <div class="job-address dump-address">${ticket.service_description || 'Waste disposal location'}</div>
                    ${tankIndicator}
                </div>
            `;
        } else {
            jobItem.innerHTML = `
                <div class="job-order" draggable="false">${index + 1}</div>
                <div class="job-details" draggable="false">
                    <div draggable="false">
                        <span class="job-time" draggable="false">${scheduledTime}</span>
                        <span class="job-service" draggable="false">${ticket.service_type || 'Service'}</span>
                        <span class="job-customer" draggable="false">${ticket.customer_name || ticket.job_id}</span>
                    </div>
                    <div class="job-address" draggable="false">${ticket.customer_address || 'Address not available'}</div>
                    ${tankIndicator}
                </div>
            `;
        }
        
        // Add drag event listeners
        jobItem.addEventListener('dragstart', handleRouteItemDragStart);
        jobItem.addEventListener('dragend', handleRouteItemDragEnd);
        jobItem.addEventListener('dragover', handleRouteItemDragOver);
        jobItem.addEventListener('drop', handleRouteItemDrop);
        jobItem.addEventListener('dragenter', e => e.preventDefault());
        
        // Add click handler for map navigation
        jobItem.addEventListener('click', function(e) {
            // Don't navigate if dragging
            if (draggedRouteItem) return;
            
            e.preventDefault();
            e.stopPropagation();
            
            console.log('üß≠ Route item clicked, navigating to map location for ticket:', ticket.id);
            // Pass the ticket data directly so we can use the original coordinates
            highlightTicketOnMapWithData(ticket);
        });
        
        routeJobsList.appendChild(jobItem);
    });
}


function exportRoute() {
    if (!currentMapTruckId) return;
    
    const truckName = document.getElementById('map-truck-name').textContent;
    
    // Fetch the detailed ticket data for export
    fetch(`/api/job-board?date=${currentDate}`)
        .then(response => response.json())
        .then(data => {
            const truckTickets = data.truck_schedules[currentMapTruckId] || [];
            
            if (truckTickets.length === 0) {
                alert('No jobs to export');
                return;
            }
            
            // Tickets are already sorted by route_position from the API
            // Create detailed export data
            const routeData = truckTickets.map((ticket, index) => {
                const time = ticket.scheduled_date ? 
                    new Date(ticket.scheduled_date).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}) : 
                    'Time TBD';
                return `${index + 1}. ${time} - ${ticket.service_type}\\n   Customer: ${ticket.customer_name || 'Unknown'}\\n   Address: ${ticket.customer_address || 'Address not available'}\\n   Job ID: ${ticket.job_id}\\n   Priority: ${(ticket.priority || 'medium').toUpperCase()}`;
            }).join('\\n\\n');
            
            const exportContent = `TrueTank Route Directions\\n${truckName}\\nDate: ${currentDate}\\n\\n${routeData}`;
            
            // Create and download file
            const blob = new Blob([exportContent], { type: 'text/plain' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${truckName}_Route_${currentDate.replace(/-/g, '')}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
            
            alert('Route directions exported successfully!');
        })
        .catch(error => {
            console.error('Error fetching data for export:', error);
            alert('Failed to export route - please try again');
        });
}

// Populate sidebar with truck and team information
function populateSidebarInfo(truckInfo, assignedTeamMember) {
    // Update truck information
    document.getElementById('sidebar-truck-name').textContent = truckInfo.truck_number;
    document.getElementById('truck-make-model').textContent = `${truckInfo.make} ${truckInfo.model}`;
    
    // Set capacity with appropriate unit
    let capacityText = 'Not specified';
    if (truckInfo.tank_capacity) {
        capacityText = `${truckInfo.tank_capacity} gallons`;
    }
    document.getElementById('truck-capacity-value').textContent = capacityText;
    
    // Update team assignment
    const teamMemberDiv = document.getElementById('assigned-team-member');
    if (assignedTeamMember && assignedTeamMember.name) {
        teamMemberDiv.innerHTML = `
            <div class="team-member-assigned">
                ${assignedTeamMember.name}
            </div>
            <div style="font-size: 0.85rem; color: #6c757d; margin-top: 0.25rem;">
                Assigned for ${currentDate}
            </div>
        `;
        teamMemberDiv.className = 'team-member-info';
    } else {
        teamMemberDiv.innerHTML = `
            <div class="team-member-unassigned">
                No team member assigned
            </div>
            <div style="font-size: 0.85rem; color: #6c757d; margin-top: 0.25rem;">
                Click "Team" button to assign
            </div>
        `;
        teamMemberDiv.className = 'team-member-info';
    }
    
    // Update tank tracking information
    updateTankTrackingDisplay(truckInfo);
}

// Update tank tracking display with current truck data
function updateTankTrackingDisplay(truckInfo) {
    // Get tank tracking data
    const capacity = truckInfo.tank_capacity || 3000;
    const currentLevel = truckInfo.current_tank_level || 0;
    const threshold = truckInfo.tank_full_threshold || 0.85;
    const fillPercentage = (currentLevel / capacity * 100) || 0;
    const gallonsUntilFull = Math.max(0, (capacity * threshold) - currentLevel);
    
    console.log('üõ¢Ô∏è Updating tank display:', {
        capacity, currentLevel, threshold, fillPercentage, gallonsUntilFull
    });
    
    // Update fill percentage display
    const percentEl = document.getElementById('tank-percentage');
    if (percentEl) {
        percentEl.textContent = `${fillPercentage.toFixed(1)}%`;
    }
    
    // Update tank fill bar
    const fillBar = document.getElementById('tank-fill-compact');
    if (fillBar) {
        fillBar.style.width = `${fillPercentage}%`;
        fillBar.style.background = generateTankGradient(fillPercentage);
    }
    
    // Update threshold line position
    const thresholdLine = document.getElementById('tank-threshold-compact');
    if (thresholdLine) {
        thresholdLine.style.left = `${threshold * 100}%`;
    }
    
    // Update gallons display
    const currentGallonsEl = document.getElementById('tank-current-gallons');
    const capacityGallonsEl = document.getElementById('tank-capacity-gallons');
    if (currentGallonsEl) currentGallonsEl.textContent = Math.round(currentLevel);
    if (capacityGallonsEl) capacityGallonsEl.textContent = capacity;
    
    // Update until dump display
    const untilDumpEl = document.getElementById('tank-until-dump');
    if (untilDumpEl) {
        untilDumpEl.textContent = `‚Ä¢ ${Math.round(gallonsUntilFull)} until dump`;
    }
    
    // Update status badge
    const statusBadge = document.getElementById('tank-status-badge');
    const dumpWarning = document.getElementById('tank-dump-warning');
    
    const isDumpNeeded = fillPercentage >= (threshold * 100);
    const isNearFull = fillPercentage >= (threshold * 100 * 0.9);
    
    if (statusBadge) {
        // Remove existing badge classes
        statusBadge.classList.remove('tank-badge-ok', 'tank-badge-warning', 'tank-badge-danger');
        
        if (isDumpNeeded) {
            statusBadge.textContent = 'DUMP';
            statusBadge.classList.add('tank-badge-danger');
        } else if (isNearFull) {
            statusBadge.textContent = 'NEAR FULL';
            statusBadge.classList.add('tank-badge-warning');
        } else {
            statusBadge.textContent = 'OK';
            statusBadge.classList.add('tank-badge-ok');
        }
    }
    
    // Show/hide dump warning
    if (dumpWarning) {
        dumpWarning.style.display = isDumpNeeded ? 'block' : 'none';
    }
    
    console.log('‚úÖ Tank display updated successfully');
}


// Animation functions for smooth card movement
function animateCardsAfterRemoval(removedCard) {
    const container = removedCard.closest('.ticket-list');
    if (!container) return;
    
    // Get all cards that come after the removed card
    const allCards = Array.from(container.children);
    const removedIndex = allCards.indexOf(removedCard);
    
    // Animate cards that will move up to fill the space
    allCards.slice(removedIndex + 1).forEach((card, index) => {
        if (card.classList.contains('ticket-card') || card.classList.contains('ticket-card-compact')) {
            setTimeout(() => {
                const animClass = card.classList.contains('ticket-card') ? 'ticket-card-animate' : 'ticket-card-compact-animate';
                card.classList.add(animClass);
                
                // Remove animation class after animation completes
                setTimeout(() => {
                    card.classList.remove(animClass);
                }, 200);
            }, index * 30); // Stagger the animations slightly
        }
    });
}

function animateCardsOnPlaceholder() {
    // Add subtle animation when placeholder appears
    const placeholders = document.querySelectorAll('.drop-placeholder');
    placeholders.forEach(placeholder => {
        // Get cards after the placeholder
        const container = placeholder.parentElement;
        const allElements = Array.from(container.children);
        const placeholderIndex = allElements.indexOf(placeholder);
        
        // Animate cards that come after the placeholder
        allElements.slice(placeholderIndex + 1).forEach((element, index) => {
            if (element.classList.contains('ticket-card-compact')) {
                element.style.transform = 'translateY(2px)';
                setTimeout(() => {
                    element.style.transform = '';
                }, 150);
            }
        });
    });
}

// Route drag and drop handlers for modal
let draggedRouteItem = null;
let routeDropPlaceholder = null;

function handleRouteItemDragStart(e) {
    draggedRouteItem = e.target.closest('.route-job-item');
    if (!draggedRouteItem) return;
    
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/plain', draggedRouteItem.dataset.ticketId);
    
    // Hide the original card after a delay (like main board)
    setTimeout(() => {
        if (draggedRouteItem) {
            draggedRouteItem.style.position = 'absolute';
            draggedRouteItem.style.top = '-9999px';
            draggedRouteItem.style.left = '-9999px';
            draggedRouteItem.style.zIndex = '-1';
            draggedRouteItem.classList.add('dragging');
            console.log('Hidden route item during drag');
        }
    }, 50);
}

function handleRouteItemDragEnd(e) {
    if (draggedRouteItem) {
        // Restore the card
        draggedRouteItem.style.position = '';
        draggedRouteItem.style.top = '';
        draggedRouteItem.style.left = '';
        draggedRouteItem.style.zIndex = '';
        draggedRouteItem.classList.remove('dragging');
        draggedRouteItem = null;
    }
    
    // Remove placeholder
    removeRoutePlaceholder();
}

function handleRouteItemDragOver(e) {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    
    if (!draggedRouteItem) return;
    
    const routeJobsList = document.getElementById('route-jobs-list');
    const visibleItems = [...routeJobsList.querySelectorAll('.route-job-item:not(.dragging)')];
    const mouseY = e.clientY;
    
    // Remove existing placeholder
    removeRoutePlaceholder();
    
    // Find the best position for the placeholder
    let insertBefore = null;
    
    for (let i = 0; i < visibleItems.length; i++) {
        const item = visibleItems[i];
        const rect = item.getBoundingClientRect();
        const itemCenter = rect.top + rect.height / 2;
        
        if (mouseY < itemCenter) {
            insertBefore = item;
            break;
        }
    }
    
    // Create new placeholder
    routeDropPlaceholder = document.createElement('div');
    routeDropPlaceholder.className = 'route-drop-placeholder';
    routeDropPlaceholder.textContent = 'Drop job here';
    
    if (insertBefore) {
        routeJobsList.insertBefore(routeDropPlaceholder, insertBefore);
    } else {
        routeJobsList.appendChild(routeDropPlaceholder);
    }
}

function handleRouteItemDrop(e) {
    e.preventDefault();
    e.stopPropagation();
    
    if (!draggedRouteItem || !routeDropPlaceholder) return;
    
    const routeJobsList = document.getElementById('route-jobs-list');
    const allChildren = [...routeJobsList.children];
    const placeholderIndex = allChildren.indexOf(routeDropPlaceholder);
    const oldPosition = parseInt(draggedRouteItem.dataset.routePosition);
    
    // Count route items before the placeholder (excluding the dragged one)
    // The dragged item is hidden but still in the DOM, so we need to account for this
    let visualPosition = 0;
    for (let i = 0; i < placeholderIndex; i++) {
        const child = allChildren[i];
        if (child.classList.contains('route-job-item') && child !== draggedRouteItem) {
            visualPosition++;
        }
    }
    
    // Use visual position directly - the backend now handles reordering correctly
    let newPosition = visualPosition;
    
    const draggedTicketId = draggedRouteItem.dataset.ticketId;
    
    console.log(`\n=== DROP DEBUG ===`);
    console.log(`Dragged ticket: ${draggedTicketId} (currently at position ${oldPosition})`);
    console.log(`Direction: ${oldPosition < visualPosition ? 'FORWARD/DOWN' : 'BACKWARD/UP'}`);
    const draggedIndex = allChildren.indexOf(draggedRouteItem);
    console.log(`Dragged item DOM index: ${draggedIndex}, Placeholder DOM index: ${placeholderIndex}`);
    console.log(`Visual position (where placeholder is): ${visualPosition}, New position sent to API: ${newPosition}`);
    console.log(`All children:`, allChildren.map((child, i) => {
        if (child === routeDropPlaceholder) return `${i}: [PLACEHOLDER]`;
        if (child.classList.contains('route-job-item')) {
            return `${i}: ticket-${child.dataset.ticketId}(pos:${child.dataset.routePosition})${child === draggedRouteItem ? ' [DRAGGED]' : ''}`;
        }
        return `${i}: other`;
    }));
    
    // Only update if position actually changed
    if (oldPosition !== newPosition) {
        updateRouteOrder(draggedTicketId, newPosition);
    } else {
        console.log('Position unchanged, restoring view');
        // Just refresh to restore the view
        removeRoutePlaceholder();
        if (draggedRouteItem) {
            draggedRouteItem.style.position = '';
            draggedRouteItem.style.top = '';
            draggedRouteItem.style.left = '';
            draggedRouteItem.style.zIndex = '';
            draggedRouteItem.classList.remove('dragging');
        }
    }
}

function getDragAfterElement(container, y) {
    const draggableElements = [...container.querySelectorAll('.route-job-item:not(.dragging)')];
    
    return draggableElements.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;
        
        if (offset < 0 && offset > closest.offset) {
            return { offset: offset, element: child };
        } else {
            return closest;
        }
    }, { offset: Number.NEGATIVE_INFINITY }).element;
}

function removeRoutePlaceholder() {
    if (routeDropPlaceholder) {
        routeDropPlaceholder.remove();
        routeDropPlaceholder = null;
    }
}

function handleRouteContainerDragEnter(e) {
    e.preventDefault();
}

function updateRouteOrder(ticketId, newPosition) {
    if (!currentMapTruckId) {
        console.error('No current truck ID for route update');
        return;
    }
    
    // Get all current route items to calculate proper positions
    const routeJobsList = document.getElementById('route-jobs-list');
    const allItems = [...routeJobsList.querySelectorAll('.route-job-item:not(.dragging)')];
    
    // Find the dragged item's current position
    const oldPosition = parseInt(draggedRouteItem.dataset.routePosition);
    
    console.log(`Moving ticket ${ticketId} from position ${oldPosition} to position ${newPosition}`);
    
    // We need to reorder all tickets in the truck
    const reorderData = {
        ticket_id: ticketId,
        truck_id: currentMapTruckId,
        route_position: newPosition,
        scheduled_date: new Date(currentDate + 'T09:00:00').toISOString()
    };
    
    fetch('/api/tickets/reorder-route', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(reorderData)
    })
    .then(response => response.json())
    .then(result => {
        if (result.success) {
            console.log('Route order updated successfully');
            // Refresh the map with updated data
            refreshMapData();
            // Also refresh the main job board
            loadJobBoard();
        } else {
            console.error('Route update error:', result.error);
            // Refresh anyway to restore the original order
            refreshMapData();
        }
    })
    .catch(error => {
        console.error('Error updating route order:', error);
        // Refresh to restore original order
        refreshMapData();
    });
}

function refreshMapData() {
    if (!currentMapTruckId) return;
    
    // Fetch updated data and refresh the map
    fetch(`/api/job-board?date=${currentDate}`)
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            // Update global trucks array if needed
            if (data.trucks) {
                trucks = data.trucks;
            }
            
            const truckInfo = trucks.find(t => t.id == currentMapTruckId);
            if (!truckInfo) {
                console.error('Truck not found:', currentMapTruckId);
                return;
            }
            
            const assignedTeamMember = teamAssignments[currentMapTruckId];
            const truckTickets = data.truck_schedules[currentMapTruckId] || [];
            
            console.log('Refreshing map with updated data:', truckTickets.length, 'tickets');
            
            // Re-initialize the map with fresh data
            initializeMapWithTickets(truckInfo, assignedTeamMember, truckTickets);
        })
        .catch(error => {
            console.error('Error refreshing map data:', error);
            // Don't show alert, just log the error
        });
}

// Add dump stops between jobs where necessary
async function addDumpStops() {
    if (!currentMapTruckId) {
        alert('No truck selected for dump planning');
        return;
    }
    
    const addDumpsBtn = document.getElementById('addDumpsBtn');
    const originalText = addDumpsBtn ? addDumpsBtn.innerHTML : '';
    
    try {
        if (addDumpsBtn) {
            addDumpsBtn.disabled = true;
            addDumpsBtn.innerHTML = '‚è≥ Adding Dumps...';
        }
        
        // Get current truck's jobs for the selected date
        const selectedDate = document.getElementById('selected-date').value;
        console.log(`Fetching jobs for truck ${currentMapTruckId} on date ${selectedDate}`);
        
        const truckJobsResponse = await fetch(`/api/trucks/${currentMapTruckId}/jobs?date=${selectedDate}`);
        if (!truckJobsResponse.ok) {
            const errorData = await truckJobsResponse.text();
            throw new Error(`Failed to fetch truck jobs: ${truckJobsResponse.status} - ${errorData}`);
        }
        const allTruckJobs = await truckJobsResponse.json();
        console.log('All truck jobs:', allTruckJobs);
        
        // Filter out existing dump stops to avoid calculating dumps based on dumps
        const truckJobs = allTruckJobs.filter(job => {
            const isDumpStop = job.service_type === 'Waste Disposal' || (job.job_id && job.job_id.startsWith('DUMP-'));
            return !isDumpStop;
        });
        console.log('Regular jobs (excluding dumps):', truckJobs);
        
        if (truckJobs.length === 0) {
            alert('No regular jobs scheduled for this truck to add dumps between');
            return;
        }
        
        // Get truck information for tank capacity
        console.log(`Fetching truck info for truck ${currentMapTruckId}`);
        const truckResponse = await fetch(`/api/trucks/${currentMapTruckId}`);
        if (!truckResponse.ok) {
            const errorData = await truckResponse.text();
            throw new Error(`Failed to fetch truck info: ${truckResponse.status} - ${errorData}`);
        }
        const truck = await truckResponse.json();
        console.log('Truck info:', truck);
        
        // Get all available dump sites
        console.log('Fetching dump sites');
        const dumpSitesResponse = await fetch('/api/dump-sites');
        if (!dumpSitesResponse.ok) {
            const errorData = await dumpSitesResponse.text();
            throw new Error(`Failed to fetch dump sites: ${dumpSitesResponse.status} - ${errorData}`);
        }
        const dumpSites = await dumpSitesResponse.json();
        console.log('Dump sites:', dumpSites);
        
        if (dumpSites.length === 0) {
            alert('No dump sites available. Please add dump sites in the Fleet Manager first.');
            return;
        }
        
        // Calculate where dumps are needed based on tank capacity and accumulated gallons
        console.log('Calculating dump insertions...');
        const jobsWithDumps = await calculateDumpInsertions(truckJobs, truck, dumpSites);
        console.log('Jobs with dumps calculated:', jobsWithDumps);
        
        // Update the truck's schedule with the new dump stops
        console.log('Updating truck schedule with dumps...');
        await updateTruckScheduleWithDumps(currentMapTruckId, selectedDate, jobsWithDumps);
        
        // Refresh the map and route display
        await refreshMapData();
        
        // Refresh the main job board to show new dump stops
        await loadJobBoard();
        
        // Show appropriate success message
        if (jobsWithDumps.dumpCount > 0) {
            alert(`Successfully added ${jobsWithDumps.dumpCount} dump stop${jobsWithDumps.dumpCount > 1 ? 's' : ''} to the route`);
        } else {
            alert('No dump stops needed! Current job sequence fits within tank capacity.');
        }
        
    } catch (error) {
        console.error('Error adding dump stops:', error);
        console.error('Error details:', error.message);
        if (error.response) {
            console.error('Response status:', error.response.status);
            console.error('Response data:', error.response.data);
        }
        alert(`Failed to add dump stops: ${error.message}. Check console for details.`);
    } finally {
        if (addDumpsBtn) {
            addDumpsBtn.disabled = false;
            addDumpsBtn.innerHTML = originalText;
        }
    }
}

// Calculate where dump stops need to be inserted
async function calculateDumpInsertions(jobs, truck, dumpSites) {
    const maxCapacity = truck.tank_capacity || 3000;
    const dumpThreshold = truck.tank_full_threshold || 0.8;
    const maxGallons = maxCapacity * dumpThreshold;
    
    let currentLevel = truck.current_tank_level || 0;
    let insertedDumps = 0;
    const modifiedJobs = [];
    
    for (let i = 0; i < jobs.length; i++) {
        const job = jobs[i];
        const jobGallons = job.estimated_gallons || 250; // Default estimate
        
        // Check if adding this job would exceed tank capacity
        if (currentLevel + jobGallons > maxGallons) {
            // Need to dump before this job
            const dumpSite = await findClosestDumpSite(
                i > 0 ? jobs[i-1] : null, // Previous job location, or null for first job
                job, // Current job location
                dumpSites
            );
            
            if (dumpSite) {
                // Create dump stop
                const dumpStop = {
                    id: `dump_${Date.now()}_${insertedDumps}`,
                    type: 'dump',
                    dump_site: dumpSite,
                    estimated_duration: dumpSite.estimated_dump_time || 15,
                    gallons_to_dump: currentLevel
                };
                
                modifiedJobs.push(dumpStop);
                insertedDumps++;
                
                // Reset current level after dump
                currentLevel = 0;
            }
        }
        
        // Add the regular job
        modifiedJobs.push(job);
        currentLevel += jobGallons;
    }
    
    return {
        jobs: modifiedJobs,
        dumpCount: insertedDumps
    };
}

// Find the closest dump site to the route
async function findClosestDumpSite(previousJob, currentJob, dumpSites) {
    const activeDumpSites = dumpSites.filter(site => site.is_active && site.accepts_septic_waste);
    
    if (activeDumpSites.length === 0) {
        return null;
    }
    
    // Use previous job location if available, otherwise use current job
    const referenceJob = previousJob || currentJob;
    
    if (!referenceJob.customer_gps_coordinates) {
        // If no GPS coordinates, return the first available dump site
        return activeDumpSites[0];
    }
    
    const [refLat, refLng] = referenceJob.customer_gps_coordinates.split(',').map(parseFloat);
    
    let closestSite = null;
    let minDistance = Infinity;
    
    for (const site of activeDumpSites) {
        if (site.gps_coordinates) {
            const [siteLat, siteLng] = site.gps_coordinates.split(',').map(parseFloat);
            const distance = calculateDistance(refLat, refLng, siteLat, siteLng);
            
            if (distance < minDistance) {
                minDistance = distance;
                closestSite = site;
            }
        }
    }
    
    return closestSite || activeDumpSites[0];
}

// Calculate distance between two points (Haversine formula)
function calculateDistance(lat1, lng1, lat2, lng2) {
    const R = 3959; // Earth's radius in miles
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLng = (lng2 - lng1) * Math.PI / 180;
    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
              Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
              Math.sin(dLng/2) * Math.sin(dLng/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c;
}

// Update truck schedule with dump stops
async function updateTruckScheduleWithDumps(truckId, date, jobsWithDumps) {
    const requestData = {
        truck_id: truckId,
        date: date,
        jobs_with_dumps: jobsWithDumps.jobs
    };
    console.log('Sending request to add dump stops:', requestData);
    
    const response = await fetch('/api/add-dump-stops', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(requestData)
    });
    
    if (!response.ok) {
        const errorData = await response.text();
        console.error('API Error Response:', errorData);
        throw new Error(`Failed to update truck schedule with dump stops: ${response.status} - ${errorData}`);
    }
    
    const result = await response.json();
    console.log('Add dump stops response:', result);
    return result;
}

// Multi-stop route calculation
async function calculateRoute() {
    if (!currentMapTruckId) {
        alert('No truck selected for routing');
        return;
    }
    
    // Create new AbortController for this calculation
    routeCalculationController = new AbortController();
    console.log('Created new AbortController for route calculation');
    
    const routeBtn = document.getElementById('routeBtn');
    const inlineIndicator = document.getElementById('inline-loading-indicator');
    const originalText = routeBtn.innerHTML;
    
    // Count cards in the route for timing calculation
    const routeItems = document.querySelectorAll('#route-jobs-list .route-job-item');
    const cardCount = routeItems.length;
    const totalDuration = Math.max(cardCount * 4000, 2000); // 4 seconds per card, minimum 2 seconds
    
    let progressInterval;
    
    try {
        // Show inline loading indicator
        inlineIndicator.style.display = 'flex';
        routeBtn.disabled = true;
        routeBtn.innerHTML = '‚è≥ Calculating...';
        
        // Start with 0% progress
        updateMiniProgress(0);
        
        // Smooth progress based on card count
        let progressPercent = 0;
        const incrementInterval = totalDuration / 80; // Divide total time into 80 increments for smooth progress
        progressInterval = setInterval(() => {
            if (routeCalculationController?.signal.aborted) {
                clearInterval(progressInterval);
                return;
            }
            progressPercent += 1.25; // Will reach 100% over the calculated duration
            if (progressPercent <= 80) {
                updateMiniProgress(progressPercent);
            }
        }, incrementInterval);
        
        // Call the multi-stop route API - truck's storage location will be used automatically
        // Route will be: Storage ‚Üí Customer Jobs ‚Üí Storage
        const response = await fetch(`/api/multi-stop-route/${currentMapTruckId}/${currentDate}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({}),
            signal: routeCalculationController.signal
        });
        
        // Check again if cancelled after the fetch completes but before processing
        if (routeCalculationController?.signal.aborted) {
            console.log('Route calculation was cancelled after fetch');
            return;
        }
        
        const data = await response.json();
        
        if (data.success) {
            // Clear existing route lines
            clearRouteLines();
            
            // Add route lines to map
            addRouteLinesToMap(data.route_segments);
            
            // Update sidebar with drive time information
            updateSidebarWithRoutingInfo(data);
            
            // Clear progress interval and show completion
            clearInterval(progressInterval);
            updateMiniProgress(100);
            
            // Hide loading indicator after a brief moment
            setTimeout(() => {
                inlineIndicator.style.display = 'none';
            }, 1500);
            
            alert(`Route calculated successfully!\nTotal drive time: ${data.total_drive_time} minutes\nTotal distance: ${data.total_distance} km`);
        } else {
            clearInterval(progressInterval);
            updateMiniProgress(0);
            inlineIndicator.style.display = 'none';
            alert('Failed to calculate route: ' + (data.error || 'Unknown error'));
        }
        
    } catch (error) {
        if (progressInterval) clearInterval(progressInterval);
        updateMiniProgress(0);
        inlineIndicator.style.display = 'none';
        
        if (error.name === 'AbortError') {
            console.log('Route calculation was successfully cancelled');
            // Don't show alert for cancelled requests
        } else {
            console.error('Route calculation error:', error);
            alert('Error calculating route: ' + error.message);
        }
    } finally {
        // Clean up controller and restore button state
        if (routeCalculationController) {
            routeCalculationController = null;
        }
        routeBtn.disabled = false;
        routeBtn.innerHTML = originalText;
    }
}

// Helper function to update mini progress indicator
function updateMiniProgress(percent) {
    const progressFill = document.getElementById('mini-progress-fill');
    const progressText = document.getElementById('mini-progress-percent');
    
    const roundedPercent = Math.round(percent);
    
    if (progressFill) progressFill.style.width = `${roundedPercent}%`;
    if (progressText) progressText.textContent = `${roundedPercent}%`;
}

// Clear existing route lines from map
function clearRouteLines() {
    if (truckMap) {
        truckMap.eachLayer(function(layer) {
            if (layer.options && layer.options.routeLine) {
                truckMap.removeLayer(layer);
            }
        });
    }
}

// Add route lines to the map
function addRouteLinesToMap(routeSegments) {
    if (!truckMap) {
        console.error('No truck map available for route lines');
        return;
    }
    if (!routeSegments) {
        console.error('No route segments provided');
        return;
    }
    
    console.log(`Adding ${routeSegments.length} route segments to map`);
    
    routeSegments.forEach((segment, index) => {
        console.log(`Processing segment ${index}:`, segment.from_description, '‚Üí', segment.to_description);
        
        if (segment.route_geometry) {
            try {
                // Decode the polyline geometry
                const coordinates = decodePolyline(segment.route_geometry);
                console.log(`Decoded ${coordinates.length} coordinates for segment ${index}`);
                
                if (coordinates.length === 0) {
                    console.warn(`No coordinates decoded for segment ${index}`);
                    return;
                }
                
                // Create polyline with different colors for different segments
                const colors = ['#e74c3c', '#2ecc71', '#3498db', '#f39c12', '#9b59b6', '#1abc9c'];
                const color = colors[index % colors.length];
                
                const routeLine = L.polyline(coordinates, {
                    color: color,
                    weight: 4,
                    opacity: 0.8,
                    routeLine: true // Mark this as a route line for clearing
                }).addTo(truckMap);
                
                console.log(`Added route line ${index} with color ${color} and ${coordinates.length} points`);
                
                // Add popup with segment info
                routeLine.bindPopup(`
                    <strong>${segment.from_description} ‚Üí ${segment.to_description}</strong><br>
                    Drive time: ${Math.round(segment.drive_time_minutes)} minutes<br>
                    Distance: ${segment.distance_km.toFixed(1)} km
                `);
                
            } catch (error) {
                console.error(`Error adding route line for segment ${index}:`, error);
            }
        } else {
            console.warn(`No route geometry for segment ${index}:`, segment.from_description, '‚Üí', segment.to_description);
        }
    });
}

// Update sidebar with routing information
function updateSidebarWithRoutingInfo(routeData) {
    const sidebar = document.querySelector('.route-summary-sidebar');
    if (!sidebar) {
        console.error('Sidebar not found - looking for .route-summary-sidebar');
        return;
    }
    
    // Find the route jobs list container
    let routeList = sidebar.querySelector('.route-jobs-list');
    if (!routeList) {
        console.error('Route jobs list not found - looking for .route-jobs-list');
        return;
    }
    
    // Clear existing drive time boxes
    sidebar.querySelectorAll('.drive-time-box').forEach(box => box.remove());
    
    // Add drive time boxes between route items and for start/end
    const routeItems = routeList.querySelectorAll('.route-job-item');
    console.log(`Found ${routeItems.length} route items, ${routeData.route_segments.length} segments`);
    
    // Debug: Log all route items
    console.log('=== ROUTE ITEMS ===');
    routeItems.forEach((item, index) => {
        console.log(`Route Item ${index}:`, item.textContent.trim());
    });
    
    // Debug: Log all route segments  
    console.log('=== ROUTE SEGMENTS ===');
    routeData.route_segments.forEach((segment, index) => {
        console.log(`Segment ${index}: ${segment.from_description} ‚Üí ${segment.to_description} (${segment.drive_time_minutes} min)`);
    });
    console.log('======================');
    
    // Process segments in the correct order to place drive time boxes
    // Expected structure: Storage ‚Üí Job1 ‚Üí Job2 ‚Üí ... ‚Üí JobN ‚Üí Storage
    routeData.route_segments.forEach((segment, segmentIndex) => {
        const isStartSegment = segment.from_description.includes('Storage') || segment.from_description.includes('Equipment');
        const isEndSegment = segment.to_description.includes('Storage') || segment.to_description.includes('Equipment');
        
        console.log(`Processing segment ${segmentIndex}: ${segment.from_description} ‚Üí ${segment.to_description}`);
        console.log(`  isStartSegment: ${isStartSegment}, isEndSegment: ${isEndSegment}`);
        
        let insertLocation = null;
        let insertPosition = 'afterend';
        
        if (segmentIndex === 0) {
            // First segment (Storage ‚Üí First Job) - insert before first job
            insertLocation = routeItems[0];
            insertPosition = 'beforebegin';
            console.log(`  Inserting BEFORE first job`);
        } else if (segmentIndex === routeData.route_segments.length - 1) {
            // Last segment (Last Job ‚Üí Storage) - insert after last job
            insertLocation = routeItems[routeItems.length - 1];
            insertPosition = 'afterend';
            console.log(`  Inserting AFTER last job`);
        } else {
            // Between jobs - insert after the job that corresponds to this segment
            // Segment 1 is Job1‚ÜíJob2, so insert after Job1 (routeItems[0])
            // Segment 2 is Job2‚ÜíJob3, so insert after Job2 (routeItems[1])
            const jobIndex = segmentIndex - 1;
            if (jobIndex >= 0 && jobIndex < routeItems.length) {
                insertLocation = routeItems[jobIndex];
                insertPosition = 'afterend';
                console.log(`  Inserting after job ${jobIndex + 1}`);
            }
        }
        
        if (insertLocation) {
            const driveTimeBox = document.createElement('div');
            driveTimeBox.className = 'drive-time-box';
            
            if (isStartSegment) {
                driveTimeBox.classList.add('drive-time-start');
            } else if (isEndSegment) {
                driveTimeBox.classList.add('drive-time-end');
            }
            
            driveTimeBox.innerHTML = `
                <div class="drive-time-content">
                    <div class="drive-time-icon">${isStartSegment ? 'üè≠' : isEndSegment ? 'üè≠' : 'üöó'}</div>
                    <div class="drive-time-details">
                        <div class="drive-time-duration">${Math.round(segment.drive_time_minutes)} min</div>
                        <div class="drive-time-distance">${segment.distance_km.toFixed(1)} km</div>
                        <div class="drive-time-route">${segment.from_description} ‚Üí ${segment.to_description}</div>
                    </div>
                </div>
            `;
            
            console.log(`  üéØ Inserting drive time box ${insertPosition} element:`, insertLocation.textContent.trim());
            console.log(`  üì¶ Drive time box content: ${Math.round(segment.drive_time_minutes)} min - ${segment.from_description} ‚Üí ${segment.to_description}`);
            
            // Insert the drive time box
            insertLocation.insertAdjacentElement(insertPosition, driveTimeBox);
            console.log(`  ‚úÖ Successfully inserted drive time box`);
            
            // Debug: Show current sidebar structure after insertion
            console.log(`  üìã Sidebar structure after insertion:`, routeList.children.length, 'total children');
        } else {
            console.log(`  ‚ùå No insert location found for segment ${segmentIndex}`);
        }
    });
}

// Simple polyline decoder (basic implementation)
function decodePolyline(encoded) {
    const coordinates = [];
    let index = 0, len = encoded.length;
    let lat = 0, lng = 0;
    
    while (index < len) {
        let b, shift = 0, result = 0;
        do {
            b = encoded.charCodeAt(index++) - 63;
            result |= (b & 0x1f) << shift;
            shift += 5;
        } while (b >= 0x20);
        const dlat = ((result & 1) ? ~(result >> 1) : (result >> 1));
        lat += dlat;
        
        shift = 0;
        result = 0;
        do {
            b = encoded.charCodeAt(index++) - 63;
            result |= (b & 0x1f) << shift;
            shift += 5;
        } while (b >= 0x20);
        const dlng = ((result & 1) ? ~(result >> 1) : (result >> 1));
        lng += dlng;
        
        coordinates.push([lat / 1e5, lng / 1e5]);
    }
    
    return coordinates;
}

// Generate dynamic gradient based on tank fill percentage
function generateTankGradient(fillPercentage) {
    // Colors for the gradient
    const green = '#2ecc71';
    const yellow = '#f39c12';
    const red = '#e74c3c';
    
    if (fillPercentage <= 50) {
        // Pure green for low levels (0-50%)
        return green;
    } else if (fillPercentage <= 80) {
        // Transition from green to yellow (50-80%)
        return `linear-gradient(90deg, ${green} 0%, ${yellow} 100%)`;
    } else {
        // Transition from green through yellow to red (80-100%)
        return `linear-gradient(90deg, ${green} 0%, ${yellow} 60%, ${red} 100%)`;
    }
}

// Add manual dump card - show modal first
function addManualDumpCard() {
    if (!currentMapTruckId) {
        alert('No truck selected');
        return;
    }
    
    // Load dump sites before showing modal
    loadDumpSites().then(() => {
        // Show the modal to collect dump info
        document.getElementById('dump-info-modal').style.display = 'flex';
        
        // Clear previous values
        document.getElementById('dump-site-select').value = '';
        document.getElementById('dump-duration').value = '30';
    });
}

// Load available dump sites from API
async function loadDumpSites() {
    try {
        const response = await fetch('/api/dump-sites');
        const dumpSites = await response.json();
        
        const selectElement = document.getElementById('dump-site-select');
        selectElement.innerHTML = '<option value="">Select a dump site...</option>';
        
        // Filter to only active dump sites
        const activeSites = dumpSites.filter(site => site.is_active);
        
        activeSites.forEach(site => {
            const option = document.createElement('option');
            option.value = site.id;
            option.textContent = `${site.name} - ${site.city}, ${site.state}`;
            option.dataset.address = site.full_address;
            option.dataset.cost = site.cost_per_gallon;
            option.dataset.estimatedTime = site.estimated_dump_time;
            selectElement.appendChild(option);
        });
        
        if (activeSites.length === 0) {
            selectElement.innerHTML = '<option value="">No active dump sites available</option>';
        }
    } catch (error) {
        console.error('Error loading dump sites:', error);
        const selectElement = document.getElementById('dump-site-select');
        selectElement.innerHTML = '<option value="">Error loading dump sites</option>';
    }
}

// Close dump info modal
function closeDumpInfoModal() {
    document.getElementById('dump-info-modal').style.display = 'none';
}

// Confirm and add the dump stop
function confirmAddDump() {
    const siteSelectElement = document.getElementById('dump-site-select');
    const selectedSiteId = siteSelectElement.value;
    const duration = parseInt(document.getElementById('dump-duration').value) || 30;
    
    if (!selectedSiteId) {
        alert('Please select a dump site');
        return;
    }
    
    // Get selected option to access data attributes
    const selectedOption = siteSelectElement.options[siteSelectElement.selectedIndex];
    const siteName = selectedOption.textContent;
    const siteAddress = selectedOption.dataset.address;
    const estimatedTime = parseInt(selectedOption.dataset.estimatedTime) || duration;
    
    // Create a new dump ticket with selected dump site
    const dumpTicket = {
        id: `temp-dump-${Date.now()}`,
        job_id: `DUMP-${Date.now()}`,
        service_type: 'Waste Disposal',
        customer_name: siteName,
        customer_address: siteAddress,
        disposal_location: siteName.split(' - ')[0], // Just the name part
        service_description: `Dump at ${siteName}`,
        estimated_duration: estimatedTime,
        estimated_gallons: 0,
        priority: 'medium',
        status: 'pending',
        isDumpStop: true,
        isManual: true,
        dump_site_id: selectedSiteId
    };
    
    // Store the dump ticket temporarily
    window.tempDumpTickets = window.tempDumpTickets || {};
    window.tempDumpTickets[dumpTicket.id] = dumpTicket;
    
    // Add to the route jobs list
    const routeList = document.getElementById('route-jobs-list');
    if (routeList) {
        const dumpItem = document.createElement('div');
        dumpItem.className = 'route-job-item route-dump-stop manual-dump';
        dumpItem.draggable = true;
        dumpItem.dataset.ticketId = dumpTicket.id;
        
        // Calculate current tank fill for this position
        const currentTankFill = calculateCurrentTankFill();
        
        dumpItem.innerHTML = `
            <button class="dump-delete-btn" onclick="removeDumpCard('${dumpTicket.id}')" title="Remove dump stop">√ó</button>
            <div class="job-order dump-order">üóëÔ∏è</div>
            <div class="job-details dump-details">
                <div>
                    <span class="job-time">--:--</span>
                    <span class="job-service dump-service">Tank Dump</span>
                    <span class="job-customer dump-location">${siteName}</span>
                </div>
                <div class="job-address dump-address">${siteAddress}</div>
                <div class="tank-fill-indicator dump-indicator">
                    <span class="tank-gallons-change negative">-${currentTankFill} gal</span>
                </div>
            </div>
        `;
        
        // Insert at the top of the route list
        if (routeList.firstChild) {
            routeList.insertBefore(dumpItem, routeList.firstChild);
        } else {
            routeList.appendChild(dumpItem);
        }
        
        // Add drag and drop functionality
        addDragAndDropToItem(dumpItem);
        
        // No need to refresh - the item was already added to the DOM above
    }
    
    // Close the modal after successfully adding dump
    closeDumpInfoModal();
}

// Calculate current tank fill level
function calculateCurrentTankFill() {
    const routeList = document.getElementById('route-jobs-list');
    if (!routeList) return 0;
    
    const truckInfo = getCurrentTruckInfo();
    let currentLevel = truckInfo?.current_tank_level || 0;
    
    // Calculate fill based on first job position (since dump is added at top)
    return Math.round(currentLevel);
}

// Remove dump card
function removeDumpCard(ticketId) {
    const routeList = document.getElementById('route-jobs-list');
    if (!routeList) return;
    
    // Find and remove the dump card
    const dumpCard = routeList.querySelector(`[data-ticket-id="${ticketId}"]`);
    if (dumpCard) {
        dumpCard.remove();
        
        // Remove from temp storage
        if (window.tempDumpTickets && window.tempDumpTickets[ticketId]) {
            delete window.tempDumpTickets[ticketId];
        }
        
        // Route display is automatically updated when item is removed from DOM
    }
}

// Add drag and drop functionality to a route item
function addDragAndDropToItem(item) {
    item.addEventListener('dragstart', handleRouteItemDragStart);
    item.addEventListener('dragend', handleRouteItemDragEnd);
}

// Add auto dump card using existing dump functionality
async function addAutoDumpCard() {
    // Use the existing addDumpStops functionality which is proven to work
    await addDumpStops();
}

// Close modal when clicking outside
window.onclick = function(event) {
    const teamModal = document.getElementById('team-assignment-modal');
    const mapModal = document.getElementById('truck-map-modal');
    const dumpModal = document.getElementById('dump-info-modal');
    
    if (event.target === teamModal) {
        closeTeamModal();
    }
    if (event.target === mapModal) {
        closeTruckMapModal();
    }
    if (event.target === dumpModal) {
        closeDumpInfoModal();
    }
}
</script>
{% endblock %}

{% block scripts %}
<!-- Custom job board script is included in the template -->
{% endblock %}